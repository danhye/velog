<h1 id="알고리즘">알고리즘</h1>
<ul>
<li>문제를 해결하기 위해 수행해야 하는 절차나 방법</li>
<li>컴퓨터 과학에서의 알고리즘 → 원하는 결과를 얻기 위해 수행해야 하는 절차</li>
</ul>
<h1 id="ars">ARS</h1>
<ul>
<li>프로그래밍을 이용하여 주어진 문제를 해결하는 과정</li>
</ul>
<h3 id="무엇이-좋은-알고리즘일까">무엇이 좋은 알고리즘일까?</h3>
<p>정확성, 작업량, 메모리 사용량, 단순성, 최적성</p>
<h3 id="알고리즘을-표현하는-방법">알고리즘을 표현하는 방법</h3>
<ol>
<li>자연어</li>
<li>순서도</li>
<li>의사코드</li>
<li>Programming Lanaguage</li>
</ol>
<h1 id="시간-복잡도">시간 복잡도</h1>
<ul>
<li>알고리즘이 문제를 해결하기 위해 얼마나 많은 연산(또는 단계)를 수행하는 지 나타내는 척도</li>
<li>입력 크기가 커졌을 때 알고리즘의 처리 시간이 어떻게 증가하는 지를 파악함으로써 향후 대규모 데이터에 대해서도 효율적으로 동작할 지 예측 가능</li>
</ul>
<h1 id="빅-오o-표기법">빅-오(O) 표기법</h1>
<ul>
<li>시간 복잡도를 표현할 때 주로  사용되는 방법</li>
<li>시간 복잡도의 최댓값(최악의 경우)를 나타냄</li>
</ul>
<p>→ 입력 크기 N이 매우 커졌을 때, 연산 횟수가 어느 정도로 증가하는 지를 나타내는 방식</p>
<ul>
<li>시간 복잡도 함수 중에서 가장 큰 영향력을 주는 n에 대한 항만을 표시</li>
<li>계수는 생략하여 표시</li>
</ul>
<p><img alt="" src="https://velog.velcdn.com/images/danhye821/post/fb689ed5-948a-4c15-8253-a2359b640520/image.png" /></p>
<h1 id="aps-기본-과정">APS 기본 과정</h1>
<ul>
<li>자료구조 학습( 배열, 문자열, 스택, 큐, 연결리스트, 트리, 힙)</li>
<li>간단한 정렬 기법</li>
<li>코딩 체력을 기르는 단계</li>
</ul>
<h1 id="aps-응용-과정">APS 응용 과정</h1>
<ul>
<li>알고리즘 학습 기법 (부분집합, 조합, 순열, DFS, BFS, … )</li>
<li>고급 정렬 기법</li>
<li>컴퓨팅 사고력을 기르는 단계</li>
<li>문제풀이에 익숙해지는 단계</li>
</ul>
<h1 id="1차원-배열-array">1차원 배열 Array</h1>
<h2 id="배열">배열</h2>
<ul>
<li>동일한 데이터 타입의 값(0개 이상)들을 저장하기 위한 자료구조</li>
</ul>
<h3 id="배열의-필요성">배열의 필요성</h3>
<ul>
<li>프로그램 내에서 여러 개의 변수가 필요할 때, 전부 다른 변수명을 이용하여 접근 하는 것은 비효율적</li>
<li>배열을 사용하면 한 번의 선언을 통해서 여러 개의 데이터를 다룰 수 있음</li>
<li>여러 개의 변수를 편하게 사용하는 것이 아닌 다수의 변수로 하기 힘든 작업을 배열을 통해 쉽게 활용할 수 있음</li>
</ul>
<h3 id="1차원-배열의-선언-필요한-요소-3가지">1차원 배열의 선언 필요한 요소 3가지</h3>
<ol>
<li>자료형 : 배열을 이루는 자료형 (기초자료형, 참조자료형(클래스 선언) 모두 가능)</li>
<li>배열이름 : 프로그램에서 사용할 배열의 이름 (주소 값 저장)</li>
<li>길이 : 배열을 이루는 요소의 값 (배열은 고정된 길이)</li>
</ol>
<pre><code class="language-jsx">자료형[] 배열이름 = new 자료형[길이];
int[] nums = new int[6];</code></pre>
<h3 id="1차원-배열의-요소-접근">1차원 배열의 요소 접근</h3>
<ul>
<li>인덱스 값은 0부터 시작</li>
<li>배열의 길이를 벗어나는 값을 사용할 수 없음 (N개의 크기 → 0 ~ N-1 활용)</li>
</ul>
<pre><code class="language-jsx">public class Array01_배열의순회 {
    public static void main(String[] args) {
        int[] arr = {0, 1, 2, 3, 4, 5, 6 }; //길이는 7
        int N = arr.length; //7

        System.out.println(&quot;정방향 순회 -&gt; &quot;);
        for (int i = 0; i &lt; N; i++) {
            System.out.print(arr[i] + &quot; &quot;);
        }

        System.out.println();

        System.out.println(&quot;역방향 순회 -&gt; &quot;);
        //2-1. 반복문의 조건을 건드리는 방법
        for (int i = N-1; i &gt;= 0; i--) {
            System.out.print(arr[i] + &quot; &quot;);
        }
        System.out.println();

        //2-2. 인덱스를 건드리는 방법 (주의 요망!)
        for (int i = 0; i &lt; N; i++) {
            System.out.print(arr[N-1-i] + &quot; &quot;); //마지막 행에서 i를 뺀다.
        }
        System.out.println();
    }
}</code></pre>
<h1 id="scanner">Scanner</h1>
<ul>
<li>표준 입력(주로 콘솔)으로 부터 데이터를 쉽게 읽어오기 위해 사용되는 클래스</li>
<li><code>import java.util.Scanner;</code></li>
<li><code>Scanner sc = new Scanner(System.in);</code></li>
</ul>
<p><img alt="" src="https://velog.velcdn.com/images/danhye821/post/965d4749-5980-462e-8d57-4ed1bf095e4a/image.png" /></p>
<p><strong>주의 요망 !</strong></p>
<p>next() , nextInt() 쓰고 nextLine() 사용 시 입력이 안될 수 있음 !
nextLine() 한번 버려주고 nextLine() 사용 가능 !
next() 사용 권장</p>
<h1 id="버블-정렬-bubble-sort">버블 정렬 Bubble Sort</h1>
<h2 id="정렬">정렬</h2>
<ul>
<li>자바에서는 Arrays 클래스와 Collections 클래스에서 sort() 메서드를 지원함</li>
</ul>
<h3 id="정렬의-종류">정렬의 종류</h3>
<ul>
<li>버블 정렬 Bubble Sort</li>
<li>선택 정렬 Selection Sort</li>
<li>카운팅 정렬 Counting Sort</li>
<li>삽입 정렬 Insertion Sort</li>
<li>힙 정렬 Heap Sort</li>
<li>병합 정렬 Merge Sort</li>
<li>퀵 정렬 Quick Sort</li>
</ul>
<h2 id="버블-정렬">버블 정렬</h2>
<ul>
<li><strong>인접한 두 개의 원소를 비교하여</strong>, 크기가 순서에 맞지 않는다면 서로 교환 (swap) 하는 과정을 반복하여 <strong>정렬</strong>하는 알고리즘</li>
</ul>
<h3 id="특징">특징</h3>
<ul>
<li><p><strong>시간 복잡도 : O(n^2)</strong></p>
</li>
<li><p><strong>공간 복잡도</strong> : O(1) → 스왑할 때 변수 1개</p>
</li>
<li><p><strong>안정 정렬</strong> : 동일한 값에 상대적 순서가 유지됨 ( &lt;&gt; 선택정렬)</p>
</li>
<li><p>배열의 처음부터 끝까지 인접 원소를 짝지어 비교</p>
</li>
<li><p>비교한 두 원소의 순서가 잘못 되어 있다면 교환 (Swap) → 오름차순, 내림차순</p>
</li>
<li><p>한 사이클이 끝나면 배열의 마지막 인덱스에 가장 큰(작은) 원소가 위치</p>
</li>
<li><p>범위를 줄여 나가며 N-1번 정도 반복 수행하면 정렬 완료</p>
</li>
</ul>
<p><img alt="" src="https://velog.velcdn.com/images/danhye821/post/61403891-1cd0-45fe-884a-900c0ae0a0ea/image.png" /></p>
<pre><code class="language-java">import java.util.Arrays;

public class Array03_버블정렬 {
    public static void main(String[] args) {
        int[] arr = {55, 7, 78, 12, 42};

        //함수로 만들어도 좋다
        int N = arr.length;

        //for문 2개
        for(int i = N-1; i &gt; 0; i--) {

            for(int j = 0; j &lt; i; j++) {
                //오름차순 ( 이슈 발생 ) -&gt; 내림차순?
                if(arr[j] &gt; arr[j+1]) { //인덱스 에러 조심
                    int tmp = arr[j];
                    arr[j] = arr[j+1];
                    arr[j+1] = tmp;
                }
            }//인접한 두 개를 비교하는 반복문
            System.out.println(&quot;사이클 끝난 뒤 모습&quot;);
            System.out.println(Arrays.toString(arr));

        }// N-1번만 반복문 수행 ! (i위치는 각 사이클에서 최대 데이터가 저장될 위치)            
        System.out.println(Arrays.toString(arr));
    }
}</code></pre>
<pre><code class="language-jsx">import java.util.Arrays;

public class BubbleSort {

    //버블정렬 : 인접한 두 개의 원소를 비교하여 큰 값을 뒤로 보내는 과정 (오름차순의 경우)을 반복 ! 
    private static void bubbleSort(int[] arr) {
        final int n = arr.length;

        //면접관이 질문 ..? Q. 버블정렬 최적화 해보시오 ( X_X !!!!!!!)

        //n개의 원소를 n번 순회하며 이전 값과 이후 값을 비교하는 과정 ..!
        for (int i = 0; i &lt; n; i++) { //TODO : 비교 로직 수정 !

            //교환이 발생하지 않으면 정렬 이미 완료 !
            boolean swapped = false;

            for (int j = 0; j &lt; n - i - 1; j++) { 
                // 싸이클이 돌 때마다 마지막 배열은 더 이상 비교하지 않아도 되기 때문에
                // n - i - 1
                if(arr[j] &gt; arr[j+1]) {
                    // 두 원소를 교환
                    int temp = arr[j];
                    arr[j] = arr[j+1];
                    arr[j+1] = temp;
                    swapped = true;
                }
            }
            //교환이 아무것도 이루어지지 않았다? -&gt; 정렬이 이미 완료 되었으므로 종료한다.
            if(!swapped) break;
        }
    }

    public static void main(String[] args) {
        //아직 정렬되지 않은 배열
        int[] arr = {4, 2, 1, 6, 8, 9, 7, 3};

        //정렬 전
        System.out.println(Arrays.toString(arr));

        //버블 정렬을 실행 ! (메서드 작성)
        bubbleSort(arr);

        //정렬 후 
        System.out.println(Arrays.toString(arr));
    }
}
</code></pre>
<h1 id="검색">검색</h1>
<h3 id="검색의-종류">검색의 종류</h3>
<ul>
<li>선형 검색(Linear Search) / 순차 검색 (Sequential Search)</li>
<li>이진 검색 (Binary Search)</li>
<li>인덱싱 (Indexing)</li>
<li>탐색(DFS, BFS)</li>
</ul>
<h1 id="순차-검색-linear-search">순차 검색 (linear Search)</h1>
<ul>
<li>앞에서부터 자료를 순서대로 검색하는 방법</li>
<li>가장 간단하고 직관적인 검색 방법</li>
<li>배열이나 연결 리스트 등 순차 구조로 구현된 자료구조에서 원하는 값을 찾을 때 유용함</li>
<li>구현은 간단하지만 검색 대상의 수가 많은 경우에는 수행 시간이 급격히 증가하여 비효율적임</li>
<li>정렬 여부와 관계 없이 적용 가능함</li>
<li>첫번째 원소부터 순서대로 검색</li>
<li>해당 원소와 키 값이 일치하는 지 비교하여 일치하면 해당 위치 반환</li>
<li>자료구조의 마지막에 도달할 때까지 키 값을 찾지 못하면 검색 실패</li>
</ul>
<h3 id="정렬이-되지-않은-경우-">정렬이 되지 않은 경우 ~~</h3>
<ul>
<li>찾고자 하는 원소의 순서에 따라 비교 횟수가 결정 됨</li>
<li>첫번째 위치에서 원소를 찾으면 1번 비교, 두번째 위치에서 원소를 찾으면 2번 비교, …</li>
<li>정렬되지 않은 자료구조에서 순차검색의 평균 비교 횟수</li>
<li>시간 복잡도 : O(n)</li>
</ul>
<h3 id="정렬이-된-경우-">정렬이 된 경우 ~~</h3>
<ul>
<li>자료가 오름차순으로 정렬된 상태라고 가정</li>
<li>첫 번째 원소부터 순서대로 검색</li>
<li>해당 원소와 키 값이 일치하는 지 비교하여 일치하면 해당 위치 반환</li>
<li>해당 원소의 값이 키 값보다 크다면 찾는 원소가 없다는 것이므로 검색 종료</li>
<li>찾고자 하는 원소의 순서에 따라 비교 횟수가 결정됨</li>
<li>정렬이 되어 있으므로 검색 실패를 반환하는 경우 평균 비교 횟수가 반으로 감소</li>
<li>시간 복잡도 : O(n)</li>
</ul>
<h1 id="이진-검색binary-search">이진 검색(Binary Search)</h1>
<ul>
<li><p>키 값을 찾을 때까지 데이터의 범위를 절반씩 줄이면서 검색하는 방식</p>
</li>
<li><p>자료가 정렬된 상태여야 함</p>
</li>
<li><p>시간 복잡도 : O(log n)</p>
<ol>
<li><p>자료의 중앙에 있는 원소를 고른다,</p>
</li>
<li><p>중앙 원소의 값과 찾고자 하는 목표 값을 비교한다. </p>
</li>
<li><p>목표 값이 중앙 원소의 값보다 작으면 자료 구간의 범위를 왼쪽으로 축소</p>
<p> 목표 값이 중앙 원소의 값보다 크다면 자료 구간의 범위를 오른쪽으로 축소</p>
</li>
<li><p>찾고자 하는 값을 찾을 때까지 1~3의 과정을 반복한다.</p>
</li>
</ol>
</li>
</ul>
<h1 id="선택-정렬-selection-sort">선택 정렬 Selection Sort</h1>
<h2 id="셀렉션-알고리즘">셀렉션 알고리즘</h2>
<ul>
<li>정렬이 되어 있지 않은 배열이나 리스트에서 k번째 작은 (또는 큰) 원소를 찾아내는 알고리즘</li>
<li>최솟값, 최댓값, 중간값, 임의의 k번째 작은 값을 빠르게 구하고 싶을 대 사용</li>
</ul>
<h3 id="대표적인-셀렉션-알고리즘">대표적인 셀렉션 알고리즘</h3>
<ul>
<li>정렬 후 선택</li>
<li>퀵 셀렉트</li>
<li>Median of Medians</li>
</ul>
<h1 id="선택-정렬">선택 정렬</h1>
<p>배열에서 <strong>최솟값</strong>을 찾아 <strong>맨 앞의 원소와 교환</strong></p>
<p>매번 선택해서 자리를 정하는 것 !</p>
<h3 id="특징-1">특징</h3>
<ul>
<li><strong>시간 복잡도</strong> : O(N^2)</li>
<li><strong>공간 복잡도</strong> : O(1)</li>
<li><strong>불안정 정렬</strong></li>
</ul>
<p>정렬 되어 있지 않은 배열 혹은 리스트에서 가장 작은 또는 가장 큰 원소를 찾아 맨 앞(맨 뒤)로 옮기는 과정을 반복하여 전체를 정렬하는 과정 </p>
<h3 id="정렬-과정">정렬 과정</h3>
<ol>
<li>주어진 리스트 중에서 최솟값을 찾는다.</li>
<li>맨 앞의 원소와 가장 작은 값을 swap 한다.</li>
<li>맨 앞의 원소를 제외한 나머지 구간에 반복 수행한다.</li>
</ol>
<pre><code class="language-jsx">import java.util.Arrays;

public class SelectionSort {

    private static void selectionSort(int[] arr) {
        //선택 정렬 : 아직 정렬되지 않은 원소들 중에 최솟값 찾아 앞에 배치 (교환)
        final int n = arr.length;

        for (int i = 0; i &lt; n-1; i++) {
            //최솟값을 가진 인덱스를 임의로 i로 지정
            int minIdx = i; // 처음 : i = 0
            // [i+1 ~ n)  :  i+1 &lt;= x &lt; n 의미
            for (int j = i + 1; j &lt; n; j++) { // j = 1 ~ 6

                //두 개의 값 [minIdx] &lt;-&gt; [j] 비교해서 (교환)
                if(arr[minIdx] &lt; arr[j]) {
                    minIdx = j;
                }
            }

            //최솟값을 가지고 있는 minIdx 인덱스가 탄생 !
            if(minIdx == i) 
                continue;
            //최솟값과 현재 위치(i)를 교환
            int temp = arr[i];
            arr[i] = arr[minIdx];
            arr[minIdx] = temp;
        }
}

    public static void main(String[] args) {
        //아직 정렬되지 않은 배열
        int[] arr = {4, 2, 1, 6, 8, 9, 7, 3};

        //정렬 전
        System.out.println(Arrays.toString(arr));

        //버블 정렬을 실행 ! (메서드 작성)
        selectionSort(arr);

        //정렬 후 
        System.out.println(Arrays.toString(arr));
    }
}
</code></pre>
<h1 id="카운팅-정렬-counting-sort">카운팅 정렬 Counting Sort</h1>
<p>각 원소의 개수를 세어서 정렬, 비교하지 않는 정렬 알고리즘 → 숫자 범위가 작으면 작을 수록 빠르다</p>
<ul>
<li><p>항목들의 순서를 결정하기 위해 집합에 각 항목이 몇 개씩 있는 지 세는 작업을 하며, 선형 시간에 정렬하는 효율적인 알고리즘</p>
</li>
<li><p>안정적 정렬로 구현 가능</p>
</li>
<li><p>정수나 정수로 표현할 수 있는 자료에 대해서 정렬 가능</p>
<p>  → 각 항목의 발생 횟수를 기록하기 위해 정수 항목으로 인덱스 되는 카운트들의 배열을 사용하기 때문</p>
</li>
<li><p>카운트들을 위한 충분한 공간을 할당하려면 집합 내의 가장 큰 정수를 알아야 한다.</p>
</li>
<li><p>시간 복잡도 : O(n+k) → n은 배열의 길이, k는 정수의 최댓값</p>
</li>
</ul>
<pre><code class="language-jsx">import java.util.Arrays;

public class CountingSort {
    public static void main(String[] args) {
        // 아직 정렬되지 않은 배열
        int[] arr = { 4, 2, 1, 6, 8, 9, 7, 3 };

        // 정렬 전
        System.out.println(Arrays.toString(arr));

        // 카운팅 정렬 실시
        // 우리가 수행하게될 배열의 원소 가장 큰 값 찾기...!
        // 1. 카운팅 배열을 (크기) 선언...!
        int[] count = new int[10]; // 인덱스로 0부터 9까지

//        count[4]++;
//        count[2]++;
//        count[1]++;
        // 2. 카운팅 배열에 개수 세기...!
        for (int v : arr) {
            count[v]++;
        }

        //3. 카운팅 -&gt; 누적합 배열로 구하기
        for(int i = 1; i &lt; 10; i++) {
            count[i] += count[i-1];
        }

        //4. 결과 배열 생성
        int[] result = new int[arr.length];
        // 안정정렬 구현하기 위해서
        //5. 원본 배열을 뒤에서부터 처리 (안정 정렬을 위해)
        for (int i = arr.length - 1; i &gt;= 0; i--) {
            //원소를 넣을 위치를 찾는다. 
            int value = arr[i]; //원소값
            int idx = count[arr[i]]; //실제 인덱스 번호
            result[idx-1] = value;
            count[value]--;
        }

        // 정수 하나만을 정렬한다면, 아래의 코드를 바로 써도 무방하다 !
//        // 3. 최종적으로 누적된 값을 해당되는 인덱스 갯수만큼 출력
//        for(int i = 0; i &lt; 10; i++) {
//            // 카운팅 되어 있는 횟수 반복!
//            for(int j = 0; j &lt; count[i]; j++) { 
//                System.out.print(i + &quot;, &quot;);
//            }
//        }
//        System.out.println();

        // 정렬 후
        System.out.println(Arrays.toString(result));
    }

}
</code></pre>