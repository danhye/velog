<h2 id="중위-표기법-→-후위-표기법-변환-방법">중위 표기법 → 후위 표기법 변환 방법</h2>
<ul>
<li>수식의 각 연산자에 대해서 우선 순위에 따라 괄호를 사용하여 다시 표현</li>
<li>각 연산자를 그에 대응하는 오른쪽 괄호 뒤로 이동 시킨 뒤 괄호를 제거</li>
</ul>
<p><img alt="" src="https://velog.velcdn.com/images/danhye821/post/21ac4988-f8d7-490e-ba59-55239c2aca8d/image.png" /></p>
<h3 id="스택을-이용하는-방법-">스택을 이용하는 방법 !</h3>
<ul>
<li>입력 받은 중위 표기식을 한 글자(토큰)씩 읽으면서 진행 (charAt 등)</li>
<li>피연산자(숫자)이면 출력</li>
<li>연산자이면 스택에 저장<ul>
<li>현재 연산자의 우선순위가 스택의 연산자보다 높으면 push</li>
<li>높지않다면, 스택에서 기존 연산자를 pop 하여 출력 후 현재 연산자를 push</li>
<li>( 여는 괄호라면 스택에 push → 우선 순위가 가장 높음</li>
<li>) 닫는 괄호라면  여는 괄호까지 연산자를 꺼내어(pop) 출력</li>
</ul>
</li>
<li>과정 종료 후 스택에 남아있는 모든 연산자 pop 하여 출력\</li>
</ul>
<p><img alt="" src="https://velog.velcdn.com/images/danhye821/post/52f05810-996d-4d6a-8a81-705ba889435c/image.png" /></p>
<p><img alt="" src="https://velog.velcdn.com/images/danhye821/post/96661168-a408-4d30-8ce1-57270071e799/image.png" /></p>
<p>Q.  풀어보기</p>
<p><img alt="" src="https://velog.velcdn.com/images/danhye821/post/49e96a62-4e03-45a7-81bb-948bf11a0c38/image.png" /></p>
<pre><code class="language-java">
package day05;

import java.util.ArrayDeque;

public class Calculator1 {
    public static void main(String[] args) {
        // 입력
        String infix = &quot;2+3*4/5&quot;; // 234*5/+

        // 로직
        String postfix = &quot;&quot;; // 누적할 후위표기식
        ArrayDeque&lt;Character&gt; stack = new ArrayDeque&lt;&gt;();
        // 중위표현식을 문자열 순서대로 순회 !
        for (int i = 0; i &lt; infix.length(); i++) { // 향상된 for문으로 써라
            char ch = infix.charAt(i);

            // 피연산자 숫자일 때의 처리 -&gt; 바로 출력
            if (Character.isDigit(ch)) {
                postfix += ch;
            }
            // 여는 괄호 처리 '('
            else if (ch == '(') { // charcter은 기본자료형이라서 참조자료형이 아님 ! equals 필요 없다.
                stack.add(ch); // 얘가 가장 높기 때문에 안에 뭐가 있든 상관 없다.
            }
            // '*', '/' 처리
            // 실질적으로 가장 높은 우선순위를 가지는 연산자
            // 같은 우선순위인 */는 스택에서 빼줘라 ..! -&gt; 그 다음에 넣어라 !
            else if (ch == '*' || ch == '/') {
                // 같은 우선순위를 가진 */는 스택에서 빼줘라 ..!
                if (!stack.isEmpty() &amp;&amp; (stack.peek() == '*' || stack.peek() == '/')) {
                    postfix += stack.pop();
                }

                stack.add(ch);
            }
            // '+', '-' 처리
            // 우선순위가 같거나 더 높으 연산자가 있다면 빼라 -&gt; 그 다음에 넣어라
            else if (ch == '+' || ch == '-') {
                while (!stack.isEmpty()
                        &amp;&amp; (stack.peek() == '*' || stack.peek() == '/' || stack.peek() == '+' || stack.peek() == '-')) {
                    postfix += stack.pop();
                }

                stack.add(ch);
            }
            // 닫는 괄호 처리 ')'
            // 여는 괄호를 만날 때까지 pop!
            else if (ch == ')') {
                while (!stack.isEmpty() &amp;&amp; stack.peek() != '(') {
                    postfix += stack.pop();
                }
                stack.pop(); // 여는 괄호 버리기 ! '('
            }
        }
        // 스택에 남은 모든 연산자를 출력 !
        while (!stack.isEmpty()) {
            postfix += stack.pop();
        }

        // 후위표기식으로 출력
        System.out.println(postfix);
    }
}
</code></pre>
<pre><code class="language-java">package day05;

import java.util.ArrayDeque;
import java.util.HashMap;
import java.util.Map;

public class CalculatorUpgrade1 {

    // isp : 연산자 우선순위 (스택에 이미 들어있을 때의 우선순위)
    static Map&lt;Character, Integer&gt; isp = new HashMap&lt;&gt;();
    static {
        isp.put('(', 0);
        isp.put('*', 2);
        isp.put('/', 2);
        isp.put('+', 1);
        isp.put('-', 1);
    }

    // icp : 연산자 우선순위 (새로 들어올 때의 우선순위)
    static Map&lt;Character, Integer&gt; icp = new HashMap&lt;&gt;();
    static {
        icp.put('(', 3);
        icp.put('*', 2);
        icp.put('/', 2);
        icp.put('+', 1);
        icp.put('-', 1);
    }

    public static void main(String[] args) {
        // 입력
        String infix = &quot;2+3*4/5&quot;; // 234*5/+

        // 로직
        String postfix = &quot;&quot;; // 누적할 후위표기식
        ArrayDeque&lt;Character&gt; stack = new ArrayDeque&lt;&gt;();
        // 중위표현식을 문자열 순서대로 순회 !
        for (int i = 0; i &lt; infix.length(); i++) { // 향상된 for문으로 써라
            char ch = infix.charAt(i);

            // 피연산자 숫자일 때의 처리 -&gt; 바로 출력
            if (Character.isDigit(ch)) {
                postfix += ch;
            } else if (ch == '*' || ch == '/' || ch == '+' || ch == '-' || ch == '(') {
                // 스택 안(isp)에 우선순위가 내가 들어갈(icp) 더 높다면 빼라...!
                while (!stack.isEmpty() &amp;&amp; isp.get(stack.peek()) &gt;= icp.get(ch)) {
                    postfix += stack.pop();
                }

                stack.add(ch);
            }

            // 닫는 괄호 처리 ')'
            // 여는 괄호를 만날 때까지 pop!
            else if (ch == ')') {
                while (!stack.isEmpty() &amp;&amp; stack.peek() != '(') {
                    postfix += stack.pop();
                }
                stack.pop(); // 여는 괄호 버리기 ! '('
            }
        }
        // 스택에 남은 모든 연산자를 출력 !
        while (!stack.isEmpty()) {
            postfix += stack.pop();
        }

        // 후위표기식으로 출력
        System.out.println(postfix);
    }
}
</code></pre>
<h2 id="후위-표기법의-수식을-스택을-이용하여-계산">후위 표기법의 수식을 스택을 이용하여 계산</h2>
<ul>
<li>피연산자를 만나면 스택에 Push</li>
<li>연산자를 만나면 필요한 만큼의 피연산자를 스택에서 Pop 하여 (2개 필요) 연산하고 결과를 다시 Push</li>
<li>수식이 끝나면, 마지막으로 스택을 Pop 하여 출력</li>
</ul>
<p>피연산자를 스택에 넣을 때</p>
<p>스택을 숫자형 또는 문자열로 생성해서 넣어 </p>
<p>왜?? 한자리수 숫자를 보장해도 연산의 결과까지 한자리수 보장은 아니기에</p>
<p><img alt="" src="https://velog.velcdn.com/images/danhye821/post/19a32661-7b8f-46f2-9f41-326180539176/image.png" /></p>
<pre><code class="language-java">package day05;

import java.util.Stack;

public class Calculator2 {
    public static void main(String[] args) {
        // 입력
        String postfix = &quot;6528-*2/+&quot;; // 후위표현식

        // 로직
        Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();

        // 순차적으로 문자를 스캔한다...!
        for (char ch : postfix.toCharArray()) {
            // 피연산자 (숫자) -&gt; stack에 넣는다!
            if (Character.isDigit(ch)) {
                stack.push(ch - '0'); // Integer.parseInt(ch + &quot;&quot;)
            }
            // 연산자 +-*/ -&gt; 피연산자2개 꺼내서 연산 후 다시 넣는다!
            else {
                // 피연산자 두개 꺼내기...!
                int a = stack.pop();
                int b = stack.pop();

                int temp;
                if (ch == '+') {
                    temp = b + a;
                } else if (ch == '-') {
                    temp = b - a;
                } else if (ch == '/') {
                    temp = b / a;
                } else /* if (ch == '*') */ {
                    temp = b * a;
                }
                stack.push(temp);
            }
        }

        // 출력
        int result = stack.pop();
        System.out.println(stack.size());
        System.out.println(result);
    }
}
</code></pre>
<pre><code class="language-java">package day05;

import java.util.Map;
import java.util.Stack;

public class Calculator2Upgrade {

    private static int operator(char ch, int a, int b) {
        // 연산자( 토큰 +-/*   -&gt;   연산함수(메서드) )
        if (ch == '+') {
            return b + a;
        } else if (ch == '-') {
            return b - a;
        } else if (ch == '/') {
            return b / a;
        } else /* if (ch == '*') */ {
            return b * a;
        }
    }

    public static void main(String[] args) {
        // 입력
        String postfix = &quot;6528-*2/+&quot;; // 후위표현식

        // 로직
        Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();

        // 순차적으로 문자를 스캔한다...!
        for (char ch : postfix.toCharArray()) {
            // 피연산자 (숫자) -&gt; stack에 넣는다!
            if (Character.isDigit(ch)) {
                stack.push(ch - '0'); // Integer.parseInt(ch + &quot;&quot;)
            }
            // 연산자 +-*/ -&gt; 피연산자2개 꺼내서 연산 후 다시 넣는다!
            else {
                // 피연산자 두개 꺼내기...!
                int a = stack.pop();
                int b = stack.pop();

                stack.push(operator(ch, a, b));
            }
        }

        // 출력
        int result = stack.pop();
        System.out.println(result);
    }

}
</code></pre>
<pre><code class="language-java">package day05;

import java.util.HashMap;
import java.util.Map;
import java.util.Stack;
import java.util.function.IntBinaryOperator;

public class Calculator2Upgrade2 {

    static Map&lt;Character, IntBinaryOperator&gt; operators = new HashMap&lt;&gt;();

    static {
        operators.put('+', (a, b) -&gt; b + a);
        operators.put('-', (a, b) -&gt; b - a);
        operators.put('*', (a, b) -&gt; b * a);
        operators.put('/', (a, b) -&gt; b / a);
    }

    public static void main(String[] args) {
        // 입력
        String postfix = &quot;6528-*2/+&quot;; // 후위표현식

        // 로직
        Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();

        // 순차적으로 문자를 스캔한다...!
        for (char ch : postfix.toCharArray()) {
            // 피연산자 (숫자) -&gt; stack에 넣는다!
            if (Character.isDigit(ch)) {
                stack.push(ch - '0'); // Integer.parseInt(ch + &quot;&quot;)
            }
            // 연산자 +-*/ -&gt; 피연산자2개 꺼내서 연산 후 다시 넣는다!
            else {
                // 피연산자 두개 꺼내기...!
                int a = stack.pop();
                int b = stack.pop();

                stack.push(operators.get(ch).applyAsInt(a, b));
            }
        }

        // 출력
        int result = stack.pop();
        System.out.println(result);
    }

}
</code></pre>
<h1 id="재귀함수">재귀함수</h1>
<p>분기처리할때 !! 많이 쓰임 !</p>
<ul>
<li>자기 자신을 호출하여 순환 수행 되는 것</li>
<li>반복을 대신할 수 있음</li>
<li>함수 호출은 메모리 구조에서 스택을 사용 (이름만 같은 다른 메서드)</li>
<li>간단한 문제에 대해서는 반복문에 비해 메모리 및 속도에서 성능저하가 발생</li>
</ul>
<h3 id="재귀함수-구조">재귀함수 구조</h3>
<ul>
<li>일반적으로 기본 부분(Base case), 재귀 부분(Recursive Case)으로 구성</li>
<li><strong>Base case</strong> : 재귀 호출에서 빠져 나가기 위한 조건<ul>
<li>없으면 ? 무한루프</li>
</ul>
</li>
<li>Recursive case : 자신을 호출하는 부분 (Base case로 유도한다.)</li>
<li>재귀적 프로그램을 작성하는 것은 반복 구조에 비해 간결하고 이해하기 쉬움</li>
</ul>
<pre><code class="language-java">
public class Stack07_재귀함수 {
    static int cnt = 1;

    public static void main(String[] args) {
//        function1();
        function2(10);
    }

    // 단순히 나 자신을 호출하게 되면 .... 무한 호출 곤란해 !
    public static void function1() {
        System.out.println(&quot;function1 호출&quot; + cnt++);
        function1();
    }

    public static void function2(int num) {
        // 1. 기본 부분(재귀를 끝내는 조건)
        if (num == 0) {
            return;
        }
        // 2. 재귀를 호출하는 부분
        else {
            System.out.println(&quot;function2 호출&quot; + cnt++ + &quot;, &quot; + num);
            function2(num - 1);
        }
    }
}</code></pre>
<h3 id="재귀함수-예시">재귀함수 예시</h3>
<ul>
<li>함수에서 실행해야 하는 작업의 특성에 따라 일반적인 호출방식 보다 재귀호출 방식을 사용하여 함수를 만들면 프로그램의 크기를 줄이고 간단하게 작성 가능</li>
<li>팩토리얼 : 1부터 N까지의 모든 자연수를 곱하여 구하는 연산</li>
</ul>
<p><strong>피보나치 수</strong></p>
<ul>
<li>0과 1로 시작하고, 이전의 두수 합을 다음 항으로 하는 수열</li>
<li>0 1 1 2 3 5 8 13 …</li>
</ul>
<p>중복호출이 생길 수  있다 ~~</p>
<pre><code class="language-java">public class Stack09_피보나치 {
    static int[] count = new int[100];

    public static void main(String[] args) {
        // N은 음수가 들어오지 않는다 !
        System.out.println(fibo(45));
        // System.out.println(Arrays.toString(count));
        System.out.println(fibo2(46));
    }

    // n을 구하려면, n-1, n-2가 필요해
    private static int fibo(int n) {
        count[n]++;
        // 기본 부분
//        if(n == 0) return 0;
//        if(n == 1) return 1; 아래와 같은 의미
        if (n &lt; 2)
            return n;

        // 재귀 부분
        return fibo(n - 1) + fibo(n - 2);
    }

    // 저장해서 쓰면 중복 연산을 막을 거 같은데?
    static int[] memo = new int[50];
    static {
        memo[0] = 0;
        memo[1] = 1;
    }

    public static int fibo2(int n) {
        if (n &gt;= 2 &amp;&amp; memo[n] == 0)
            memo[n] = fibo2(n - 1) + fibo2(n - 2);
        return memo[n];
    }
}
</code></pre>
<p><strong>⭐⭐⭐⭐⭐ 하노이의 탑 ⭐⭐⭐⭐⭐</strong></p>
<ol>
<li>한 번에 한 개의 원판만 옮길 수 있다.</li>
<li>가장 위에 있는 원판만 이동할 수 있다.</li>
<li>큰 원판이 작은 원판 위에 있어서는 안된다.</li>
</ol>
<p>재귀적인 해결 방법</p>
<ol>
<li>n-1개의 원판을 A → B</li>
<li>가장 큰 원판     A → C</li>
<li>n-1개의 원판을 B → C</li>
</ol>
<pre><code class="language-java">public static void hanoi(int n, char from, char to, char via) {
    if (n == 1) {
        System.out.println(from + &quot; -&gt; &quot; + to);
    } else {
        hanoi(n-1, from, via, to);    // n-1개를 경유지로
        System.out.println(from + &quot; -&gt; &quot; + to);  // 가장 큰 원판 이동
        hanoi(n-1, via, to, from);    // n-1개를 목적지로
    }
}</code></pre>