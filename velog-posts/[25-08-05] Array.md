<h2 id="2차원-배열">2차원 배열</h2>
<ul>
<li>배열의 각 요소가 또 다른 1차원 배열을 가리킴 (크기가 일정하지 않아도 OK)</li>
<li>행(row) 과 열(column)의 구조 / 테이블 구조 / 좌표 평면 구조 등</li>
</ul>
<h2 id="2차원-배열의-선언">2차원 배열의 선언</h2>
<pre><code class="language-jsx">- 데이터타입[][] 배열이름
int[][] arr = new int[2][4];</code></pre>
<blockquote>
<p>행 / 열 각각의 인덱스 접근을 생각해보자 !</p>
</blockquote>
<blockquote>
<p>8개의 기초 자료형 : int / boolean / char / double / float / byte / short / long</p>
</blockquote>
<h2 id="2차원-배열-인덱스">2차원 배열 인덱스</h2>
<ul>
<li>인덱스를 이용하여 요소에 접근</li>
</ul>
<pre><code class="language-jsx">arr[행 인덱스][열 인덱스]
* 변수 rc 로 많이 사용 !</code></pre>
<h2 id="2차원-배열-순회">2차원 배열 순회</h2>
<ul>
<li>N x M 크기의 배열의 모든 요소를 처음부터 끝까지 (또는 일부 구간) 확인하는 방법</li>
</ul>
<h3 id="행-우선-순회">행 우선 순회</h3>
<p><img alt="" src="https://velog.velcdn.com/images/danhye821/post/f67d210e-d697-4d08-bdd5-4f3481c0d426/image.png" /></p>
<ul>
<li>행을 고정 시킨 뒤 열을 순회하는 방법</li>
</ul>
<h3 id="열-우선-순회">열 우선 순회</h3>
<p><img alt="" src="https://velog.velcdn.com/images/danhye821/post/923a96d6-704c-4321-bffa-2d973618ce77/image.png" /></p>
<ul>
<li>열을 고정 시킨 뒤 행을 순회하는 방법</li>
</ul>
<p>*고정된 배열에서 많이 사용 됨</p>
<pre><code class="language-java">
public class Array08_2차원배열순회 {
    public static void main(String[] args) {
        //문제 행/열 크기가 주어지고 다음 줄 부터 입력이 주어진다. 

//        2 4
//        1 2 3 4
//        5 6 7 8

        int[][] arr = {{1,2,3,4}, {5,6,7,8}, {9,1,2,3}};

        System.out.println(&quot;=============행우선순회=============&quot;);
        // 행 우선 순회 방식
        for(int i = 0; i &lt; arr.length; i++) {
            for(int j = 0; j &lt; arr[i].length; j++) {
                System.out.print(arr[i][j] + &quot; &quot;);
            }
            System.out.println();
        }
        // 행 우선 순회 방식 (역방향)
        // 1. for문 조건 건드리는 방식

        // 2. index를 건드리는 방식

        System.out.println(&quot;=============열우선순회=============&quot;);

        // 열 우선 순회 (정방향) -&gt; N X M 일때 ..! 0으로 고정 가능 (가변길이 배열이면 고정은 위험 !)
        for (int j = 0; j &lt; arr[0].length; j++) {
            for (int i = 0; i &lt; arr.length; i++) {
                System.out.print(arr[i][j] + &quot; &quot;);
            }
            System.out.println();
        }

        // 열 우선 순회 (역방향) -&gt; 조건/index 건드리기
    }
}
</code></pre>
<p><img alt="" src="https://velog.velcdn.com/images/danhye821/post/51ac7048-a549-446e-a601-4f80ccd59a8a/image.png" /></p>
<h3 id="지그재그-순회">지그재그 순회</h3>
<p><img alt="" src="https://velog.velcdn.com/images/danhye821/post/3aacb416-d298-4535-b4d7-0a69653a9597/image.png" /></p>
<ul>
<li>짝수 행 : 왼 → 오</li>
<li>홀수 행 : 왼 ← 오</li>
</ul>
<pre><code class="language-java">&lt;&lt;&lt;&lt;&lt; 공식 &gt;&gt;&gt;&gt;&gt;
int i; // 행의 좌표
int j; // 열의 좌표

for i from 0 to n-1
    for j from 0 to m-1
        Array[i][j+(m-1-2*j) * (i%2)] </code></pre>
<h3 id="달팽이-순회">달팽이 순회</h3>
<p><img alt="" src="https://velog.velcdn.com/images/danhye821/post/d32f98b9-2fd8-4dad-a5bb-500618d6c27f/image.png" /></p>
<p><strong>규칙을 찾아야 해 !</strong></p>
<p><img alt="" src="https://velog.velcdn.com/images/danhye821/post/6d88bca8-0188-4317-a62b-73e0c66418f4/image.png" /></p>
<p>수평 → 수직  : 1칸씩 감소</p>
<p>수직 → 수평</p>
<ul>
<li>반대방향으로 돌기, 시작점이 다르게 돌기, 안에서 밖으로 돌기, 크기가 다른 경우도 연습해보자 .. ㅠㅠ</li>
</ul>
<h3 id="가변-길이-2차원-배열-순회">가변 길이 2차원 배열 순회</h3>
<ul>
<li>1차원 배열의 길이가 다른 배열 순회</li>
</ul>
<p><img alt="" src="https://velog.velcdn.com/images/danhye821/post/c0f675de-86bb-4ad1-9b15-fbb5e1364be8/image.png" /></p>
<pre><code class="language-java"># 행 우선 순위 방식 !
for(i 0-&gt; N)
    for(j 0 -&gt; arr[i].len)
        arr[i][j]


# 열 우선 순위 방식 !

가장 큰 행의 길이를 미리 받아놓고, 
가장 큰 행보다 작다면 continue &lt;- 가능 

여러가지 방법 가능 .. ㅠ</code></pre>
<ul>
<li>모래시계 순회, 별 찍기,  위로 상승하는 순회…….</li>
</ul>
<h2 id="⭐-델타를-활용한-이동">⭐ 델타를 활용한 이동</h2>
<ul>
<li>2차원 배열에서 상하좌우 또는 대각선 등 여러 방향으로 위치를 옮길 때, 규칙적으로 변하는 변화량을 정의하여 활용하는 방식</li>
</ul>
<pre><code class="language-jsx">
public class Array09_델타 {
    //상하좌우 정리를 해보자 ! (static 키워드를 사용하는 경우가 많다 !)
    static int[] dr = {-1, 1, 0, 0}; //행의 변화량 dy | dx (주의) | di
    static int[] dc = {0, 0, -1, 1}; //열의 변화량 dx | dy (주의) | dj
    static int[][] drc = {{-1,0}, {1,0},{0,-1},{0,1}}; // 2차원 배열 [dir][0] 행, [dir][1] 열

    public static void main(String[] args) {
        int N = 3;
        int[][] arr = new int[N][N];
//        //0  0  0
//        //0 [0] 0
//        //0  0  0
//        
//        int r = 1;
//        int c = 1;

        //0  0  0
        //0  0  0
        //0 [0] 0

        int r = 2;
        int c = 1;

        for (int d = 0; d &lt; 4; d++) {
            //d 방향으로 이동했을 경우 좌표값 (nr, nc)
            int nr = r + dr[d];
            int nc = c + dc[d];

            System.out.println(nr + &quot; , &quot; + nc);

            // 거기 갈 수 있나요 ? 물어봐야겠다.
            System.out.println(&quot;========= 방법 1 ==========&quot;);
            // 1. 내 안에 들어오면 진행해
            if(nr &gt;= 0 &amp;&amp; nr &lt; N &amp;&amp; nc &gt;= 0 &amp;&amp; nc &lt; N) {
                System.out.println(arr[nr][nc]);
            }

            System.out.println(&quot;========= 방법 2 ==========&quot;);
            //2. 내 밖이네? 그럼 넘어가 ~
            if(nr &lt;0 || nr &gt;= N || nc &lt; 0 || nc &gt;= N) 
                continue;
            System.out.println(arr[nr][nc]);

        }// 4방향 탐색

    }
}
</code></pre>
<h2 id="전치행렬">전치행렬</h2>
<ul>
<li>행렬의 행과 열을 서로 바꾼 형태의 행렬</li>
</ul>
<p><img alt="" src="https://velog.velcdn.com/images/danhye821/post/5d793469-e986-4c47-a755-9af1f29857d7/image.png" /></p>
<h2 id="배열-회전">배열 회전</h2>
<ul>
<li><strong>시계방향으로 90도 회전</strong></li>
</ul>
<pre><code class="language-java">for(i 0 -&gt; N)
    for(j 0 -&gt; N)
        rArr[i][j] = arr[N-1-j][i]</code></pre>
<ul>
<li>시계방향으로 180도 회전</li>
</ul>
<pre><code class="language-java">for(i 0 -&gt; N)
    for(j 0 -&gt; N)
        rArr[i][j] = arr[N-1-i][N-1-j]
                        (고정)</code></pre>
<ul>
<li>시계방향으로 270도 회전</li>
</ul>
<pre><code class="language-java">for(i 0 -&gt; N)
    for(j 0 -&gt; N)
        rArr[i][j] = arr[j][N-1-i]
                            (고정)</code></pre>
<h1 id="다차원-배열">다차원 배열</h1>
<ul>
<li>배열 안에 또 다른 배열을 포함하는 구조</li>
<li>일반적으로 2차원 배열 (행렬 형태)가 많지만 3차원 이상도 가능</li>
<li>표 형태 혹은 복잡한 계층 구조를 표현할 때 유용</li>
<li>배열 객체의 참조 값을 요소로 갖는 배열</li>
<li>n차원 배열은  배열의 요소로 n-1 치원 배열의 참조를 가지는 배열</li>
<li>n차원 배열의 요소에 접근하기 위해서는 n개의 인덱스가 필요</li>
</ul>