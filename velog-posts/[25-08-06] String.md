<h3 id="ascii-코드">ascii 코드</h3>
<p><img alt="" src="https://velog.velcdn.com/images/danhye821/post/79636a41-73bd-449b-b815-6648bab34f74/image.png" /></p>
<h1 id="문자열string">문자열(String)</h1>
<ul>
<li>문자(Character)들의 나열 → 문자를 순서대로 저장한 자료구조</li>
<li>문자열의 구체적인 표현 방식(메모리 구조)은 언어 / 환경에 따라 다름</li>
<li>java에는 java.lang.String</li>
</ul>
<h2 id="string-클래스에-대한-메모리-배치-예">String 클래스에 대한 메모리 배치 예</h2>
<ul>
<li>Java.lang.String 클래스에는 아래 네가지 필드 포함<ul>
<li>hash 값</li>
<li>문자열의 길이 count</li>
<li>문자열 데이터의 시작점 offset</li>
<li>실제 문자열 배열에 대한 참조 value</li>
</ul>
</li>
</ul>
<h2 id="string-클래스-특징">String 클래스 특징</h2>
<ul>
<li>불변 !<ul>
<li>한 번 생성된 String 객체는 내부 내용을 변경할 수 없음</li>
</ul>
</li>
<li>힙(Heap)에 저장 + String Pool<ul>
<li>동일 릴터럴(내용이 같고, 코드 상 동일한 hello) 이면 이미 존재하는 객체를 재사용</li>
<li>그래서 == 비교가 가능해</li>
</ul>
</li>
<li>내부 구조 UTF-16기반</li>
</ul>
<h2 id="string-생성">String 생성</h2>
<ol>
<li>리터럴 사용</li>
<li>생성자 사용</li>
</ol>
<pre><code class="language-java">import java.nio.charset.StandardCharsets;
import java.util.Arrays;
import java.util.Scanner;

public class String01_생성 {
    public static void main(String[] args) {
        // 1.리터럴 사용 -&gt; String Pool
        String str1 = &quot;Hello&quot;;
        String str2 = &quot;Hello&quot;; // 두개의 변수는 하나의 &quot;Hello&quot;를 가리키고 있다.

        System.out.println(str1 == str2); // 객체에서 == 비교연산자는 주소비교
        System.out.println(str1.equals(str2));

        // 2. 힙에 직접 생성
        String str3 = new String(&quot;Hello&quot;);
        System.out.println(str1 == str3); // false
        System.out.println(str1.equals(str3)); // true

        // 3. byte 배열 이용
        byte[] bytes = new byte[] { 65, 66, 67 };
        String str4 = new String(bytes, StandardCharsets.UTF_8);
        System.out.println(str4);

        ////////////////////////////////////////////////////////
        // 문자열은 불변성 ! -&gt; 중간 문자를 바꾸고 싶다 ! -&gt; 문자의 배열로 바꾸고 -&gt; 값을 갱신 한 뒤 -&gt; 다시 문자열로
        char[] cArr1 = new char[str1.length()];

        for (int i = 0; i &lt; cArr1.length; i++) {
            cArr1[i] = str1.charAt(i);
        }
        System.out.println(Arrays.toString(cArr1)); // [H, e, l, l, o]

        char[] cArr2 = str1.toCharArray();
        System.out.println(Arrays.toString(cArr2)); // [H, e, l, l, o]

        // Java에서 문자 한개를 입력 받는 방법 X
        Scanner sc = new Scanner(System.in);
//        String tmp = sc.next();
//        sc.next().charAt(0); // 해당 방식으로 문자열을 입력 받을 수 있다.

        //패턴매칭
        System.out.println(str1.contains(&quot;la&quot;));

    }
}</code></pre>
<p><img alt="" src="https://velog.velcdn.com/images/danhye821/post/f5aa1f22-58ad-4c5f-b31e-1c63549d50aa/image.png" /></p>
<h2 id="회문">회문</h2>
<ul>
<li>앞에서부터 읽는 것과 뒤에서부터 읽는 것이 동일한 문자열</li>
<li>회문 판별을 위해서는 문자열을 뒤집을 수 있어야 함<ol>
<li>반복문을 통해 뒤에서부터 읽어 오기</li>
<li>StringBuilder 또는 StringBuffer 클래스의 reverse() 메서드 활용하기</li>
<li>양쪽 끝에서 시작하여 swap을 통해 뒤집기</li>
</ol>
</li>
</ul>
<pre><code class="language-java">public class String02_회문 {
    public static void main(String[] args) {
        String str = &quot;다시합창합시다!&quot;;

        int N = str.length();

        // 1. 뒤집기(반복문)
        char[] arr = new char[N];
        for (int i = 0; i &lt; N; i++) {
            arr[i] = str.charAt(N - 1 - i);
        }
        String str2 = new String(arr);
        System.out.println(str2);

        // 2. StringBuilder
        StringBuilder sb = new StringBuilder();
        sb.append(str).reverse().append(&quot;스트링빌더지롱&quot;);
        System.out.println(sb);

        // 3. Swap
        char[] arr2 = str.toCharArray();
        for (int i = 0; i &lt; N / 2; i++) {
            // swap (i의 증가에 따라 폭이 점점 줄어든다.)
            char tmp = arr2[i];
            arr2[i] = arr2[N - 1 - i];
            arr2[N - 1 - i] = tmp;
        }
        System.out.println(new String(arr2));
    }
}
</code></pre>
<p>*참고
<img alt="" src="https://velog.velcdn.com/images/danhye821/post/b8d1c39c-0102-4153-a7e8-72c123303f0d/image.png" /></p>
<pre><code class="language-java">package day03;

public class StringReverseTest {
    /**
     * text 문자열을 역으로 뒤집어서 반환하겠다
     * 
     * @param text 원본 문자열
     * @return 뒤집은 문자열
     */
    private static String reverse(String text) {
        // 문자열의 길이
        int length = text.length();

        // 문자 배열 전환 ( String 은 변경 불가 ! -&gt; 배열로 전환 )
        char[] chArr = text.toCharArray();

        // 문자열을 뒤집는다 !
        // 1. 문자열의 절반만 순회
        for (int i = 0; i &lt; length / 2; i++) {
            // 2. 문자를 서로 교환(swap)
            // chArr[i] &lt;-&gt; chArr[n-1-i]
            char temp = chArr[i];
            chArr[i] = chArr[length - 1 - i];
            chArr[length - 1 - i] = temp;
        }

        // return new String(chArr); // &lt;- 가능
        return String.valueOf(chArr); // &lt;- 가능
    }

    /**
     * text 문자열을 역으로 뒤집어서 반환하겠다 (StringBuilder 객체)
     * 
     * @param text 원본 문자열
     * @return 뒤집은 문자열
     */
    private static String reverse2(String text) {
//        String word = &quot;a&quot; + &quot;bbb&quot; + &quot;cccc&quot;; // 이건 문자열이 많으면 많을 수록 속도가 느려짐
        StringBuilder sb = new StringBuilder(text); // 속도 훨씬 빠름
//        sb.append(&quot;새로운 문자열&quot;);
//        sb.append(&quot;\n&quot;);
        String reversed = sb.reverse().toString();
        String result = sb.toString();
//        return result;
        return reversed;
    }

    public static void main(String[] args) {
        String text = &quot;algorithm&quot;;

        String reversed = reverse(text);
        String reversed2 = reverse2(text);
        System.out.println(reversed);
        System.out.println(reversed2);
    }
}
</code></pre>
<h3 id="문자열-→-정수-정수-→-문자열-변환">문자열 → 정수, 정수 → 문자열 변환</h3>
<ul>
<li>atoi() : 문자를 숫자로</li>
<li>itoa() : 숫자를 문자로</li>
<li>Java 에서는 ? Integer.parseInt(String), 역함수로는 toString()</li>
</ul>
<pre><code class="language-java">public class String03_정수변환 {
    public static void main(String[] args) {
        String strNum = &quot;123456&quot;;
        // 문자열 -&gt; 정수
        int num = Integer.parseInt(strNum);
        System.out.println(num);

        System.out.println(atoi(strNum));

        System.out.println((int) '0');
    }

    // str은 아주 깔끔한 형태의 숫자만 들어온다. 예를 들어 &quot;123456&quot;
    // 우리의 입맛대로 커스텀 가능 -&gt; 정방향으로 처리 했지만, &lt;- 역방향은?
    // 음수가 들어오면 어떻게 하지?
    // 실수가 들어오면 어떻게 하지?
    public static int atoi(String str) { // ascii to integer
        int N = str.length();
        int num = 0; // 반환

        // 1 2 3 4 5 6 (인덱스 아님, 값)
        for (int i = 0; i &lt; N; i++) {
            char c = str.charAt(i); // '1', '2', '3', ...

            if (c &gt;= '0' &amp;&amp; c &lt;= '9')
                num = (num * 10) + (c - 48);

        }
        return num;
    }

    // 정수 -&gt; 문자열로 (마음의 숙제 !)
    public static String itoa(int num) {
        String strNum = num + &quot;&quot;;
        return null;
    }
}
</code></pre>
<pre><code class="language-java">package day03;

public class IntegerToStringTest {
    private static int atoi(char[] chs) {
        int result = 0; // 결과 누적
        for (char ch : chs) {
            result = result * 10 + (ch - '0'); // 10 + 2
        }
        return result;
    }

    private static int atoi(String str) {
        // &quot;1234&quot; -&gt; '1', '2', '3', '4' -&gt; 1, 2, 3, 4 -&gt; 1 12 123 1234 -&gt; 1234
        // 숫자로 해당 문자를 하나씩 뜯어서 숫자화 ..!
        int result = 0; // 결과 누적
        // 문자열에서 문자들을 순회
        for (char ch : str.toCharArray()) {
            // 아스키코드 =&gt; 숫자
            // ch('7') -&gt; '0'(48) =&gt; ch - '0'
            result = result * 10 + (ch - '0'); // 1, 2, 3, 4
        }

        return 0;
    }

    public static void main(String[] args) {
        String str = &quot;1234&quot;;
        int num = atoi(str);
        System.out.println(num + 1); // 1235
    }
}</code></pre>
<p><img alt="image.png" src="attachment:db22ba9c-13ec-46db-8ac5-dc4f8f784c0a:image.png" /></p>
<pre><code class="language-java">package day03;

public class StringToIntegerTest {
    /**
     * num 정수를 문자열로 반환하는 함수
     * 
     * @param num
     * @return
     */
    private static String itoa(int num) { // 1234 -&gt; 123,4
//        return String.valueOf(num);
//        return num + &quot;&quot;;
        // num 값을 10으로 나누면서 한자리씩 문자열로 전환
        StringBuilder sb = new StringBuilder();
        while (num &gt; 0) {
            // 한자리씩 자릿수 빼낸다..!
            int remain = num % 10; // 나머지 4
            num = num / 10; // 몫 123
            sb.append(remain);
        }
        return sb.reverse().toString();
    }

    public static void main(String[] args) {
        int num = 1234;
        String text = itoa(num);
        System.out.println(text);
    }

}
</code></pre>
<h2 id="패턴-매칭">패턴 매칭</h2>
<ul>
<li>문자열에서 특정 규칙을 찾아내거나, 해당 패턴의 일치 여부를 검사하는 과정</li>
<li>특정 키워드를 검색</li>
<li>사용자 입력이 형식에 맞게 작성하였는 지 검사</li>
<li>데이터 추출 등에서 활용할 수 있음</li>
<li>정규 표현식을 이용할 수 있음</li>
</ul>
<h3 id="패턴-매칭-알고리즘">패턴 매칭 알고리즘</h3>
<ul>
<li>Brute Force 알고리즘</li>
<li>Boyer-Moore 알고리즘</li>
<li>Rabin-Karp 알고리즘</li>
<li>KMP(Knuth-Morris-Pratt) 알고리즘</li>
</ul>
<p><img alt="" src="https://velog.velcdn.com/images/danhye821/post/e7b11dc4-9a3c-46b0-b3bc-8cd0dc21d613/image.png" /></p>
<h2 id="brute-force-알고리즘-고지식한-알고리즘">Brute Force 알고리즘 (고지식한 알고리즘)</h2>
<ul>
<li>본문 문자열을 처음부터 끝까지 차례대로 순회하면서 패턴 내의 문자들을 전부 비교하는 방식으로 동작</li>
<li>indexOf 랑 동일한 동작</li>
</ul>
<pre><code class="language-java">
public class String04_패턴매칭_브루트포스 {
    public static void main(String[] args) {
        String text = &quot;This iss a book&quot;;
        String pattern = &quot;iss&quot;;
    }

    // 찾는 순간 해당 위치의 인덱스를 반환 (없으면 -1을 반환하겠다)
    public static int matchingFor(String t, String p) {

        // 길이를 뽑아내자
        int N = t.length();
        int M = p.length();

        for (int i = 0; i &lt; N - M + 1; i++) {
            boolean isOk = true;
            for (int j = 0; j &lt; M; j++) {
                if (t.charAt(i + j) != p.charAt(j)) {
                    isOk = false;
                    break;
                }
            } // 패턴 검사 하자
            if (isOk) {
                // 찾았는데?
                return i;
            }
        } // 시작점을 위한 for문인데 경계를 잘 확인하즈아

        // 못찾았을 때
        return -1;
    }
}
</code></pre>
<pre><code class="language-java">package day03;

public class BruteForceSearchTest {
    private static int bruteForce(String p, String text) {
        // 패턴의 길이랑 텍스트의 길이
        int M = p.length(); // 패턴의 길이
        int N = text.length(); // 텍스트 길이

        // for문으로 부르트포스 로직 구현
        int j = 0;
        for (int i = 0; i &lt; N - M - i + 1; i++) {
            // N-M+1 인 이유?
            // 1~9 까지의 갯수를 알고싶으면 9 - 1 + 1 ~~
            for (; j &lt; M; j++) {
                // 문자 비교 text[i] &lt;-&gt; p[j]
                // 해당 패턴 매칭 실패 ! -&gt; 다음 매칭으로 ! break
                if (text.charAt(i + j) != p.charAt(j)) {
                    break;
                }
            }
            // 패턴 매칭 성공 케이스 !
            if (j == M) {
                return i;
            }
        }

        return -1; // 실패 ㅠㅠ!
    }

    public static void main(String[] args) {
        // 찾을 패턴
        String p = &quot;is&quot;;
        // 전체 문자열
        String text = &quot;cat is animal&quot;;
        // 무식한 조회 방법 : bruteForceSearch 메서드 만들어보기 !
        int idx = bruteForce(p, text);
        int idx2 = text.indexOf(p);

        System.out.println(&quot;인덱스 위치 : &quot; + idx);
        System.out.println(&quot;인덱스 위치 : &quot; + idx2d);
    }
}
</code></pre>
<h3 id="brute-force-알고리즘-시간-복잡도">Brute Force 알고리즘 시간 복잡도</h3>
<ul>
<li>최악의 경우 시간 복잡도는 텍스트의 모든 위치에서 패턴을 비교해야 하므로 O(MN)이</li>
</ul>
<h2 id="보이어-무어-알고리즘">보이어-무어 알고리즘</h2>
<ul>
<li>오른쪽에서 왼쪽으로 비교</li>
<li>대부분의 상용 소프트웨어에서 채택하고 있는 알고리즘</li>
<li>보이어-무어 알고리즘은 패턴에 오른쪽 끝에 있는 문자가 불일치하고 이 문자가 패턴 내에 존재하지 않는 경우, 이동 거리는 무려 패턴의 길이만큼 가능하다</li>
</ul>
<p><img alt="" src="https://velog.velcdn.com/images/danhye821/post/e9e5bb38-1d0a-4f1c-bcb0-b1b9048b07f2/image.png" /></p>