<h1 id="스택">스택</h1>
<ul>
<li><strong>선형</strong> 자료<strong>구조</strong> (1:1)</li>
<li><strong>**후입선출</strong> (<strong>LIFO</strong>, Last-In First-Out)<ul>
<li>예시 : push 1, 2, 3 → pop 3, 2, 1</li>
</ul>
</li>
<li>top 변수로 마지막에 삽입된 원소를 가리킴</li>
</ul>
<h2 id="스택의-구조">스택의 구조</h2>
<p><img alt="" src="https://velog.velcdn.com/images/danhye821/post/e201ed5c-e4ec-48f7-9548-c550fc845ce1/image.png" /></p>
<h2 id="스택stack의-주요-연산">스택(stack)의 주요 연산</h2>
<table>
<thead>
<tr>
<th><strong>push</strong> (삽입)</th>
<th>스택의 맨 위에 원소를 삽입</th>
</tr>
</thead>
<tbody><tr>
<td><strong>pop</strong> (삭제)</td>
<td>스택의 맨 위 원소를 꺼내서 반환 (공백인 경우 예외 상황)</td>
</tr>
<tr>
<td><strong>isEmpty</strong> (공백상태 확인 )</td>
<td>스택이 비어 있는 지 확인</td>
</tr>
<tr>
<td><strong>peek</strong> (마지막 원소 확인)</td>
<td>스택의 맨 위 원소를 반환 (삭제 X)</td>
</tr>
<tr>
<td><strong>isFull</strong></td>
<td>스택이 가득 찾는지 확인</td>
</tr>
<tr>
<td>- top : 가장 위의 원소를 가리킴</td>
<td></td>
</tr>
<tr>
<td>- 비어있을 경우 -1 반환</td>
<td></td>
</tr>
</tbody></table>
<h2 id="스택stack-구현">스택(stack) 구현</h2>
<ul>
<li>배열(Array) 활용</li>
<li>연결리스트(LinkedList) 활용</li>
<li>구현 클래스 (java.util.Stack)</li>
</ul>
<p><img alt="" src="https://velog.velcdn.com/images/danhye821/post/753ff4ac-5776-4816-83f9-77d4ca5d6dea/image.png" /></p>
<pre><code class="language-java">import java.util.Stack;

public class Stack01_API {
    public static void main(String[] args) {
        // &lt;참조자료형&gt;
        Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();
        // 숫자를 담을 수 있는 스택
        // Stack&lt;String&gt; stack = new Stack&lt;&gt;();
        // 문자를 담을 수 있는 스택

        // 다형성에 의해서
        // List&lt;&gt; stack2 = new Stack&lt;&gt;(); 이거 가능 !

        // 주요 메서드
        // 1. push(item) * item : 참조자료형
        int result = stack.push(10); // 반환 결과는 item이 반환된다.
        System.out.println(result);

        stack.push(20);
        stack.push(30);

        // 2. pop()
        System.out.println(stack.pop());
        System.out.println(stack.pop());
        System.out.println(stack.pop());
//        System.out.println(stack.pop()); // stack이 빈 상태이면 EmptyStackException 예외 발생

        // 무작정 빼면 안될 것 같아 .. 비어있니 쳌
        // 3. isEmpty()
        System.out.println(stack.isEmpty());
        // 안에 있는 거 전부 빼라
        stack.clear(); // 스택을 초기화 해버리는 것 ! ㅠㅠ

        // 아래는 무한루프
//        while(stack.isEmpty()) {
//            stack.pop();
//        }

        // 조건을 확인해보자 (아래 두개는 동일 의미)
        while (!stack.isEmpty()) {
            stack.pop();
        }

        while (stack.size() &gt; 0) {
            stack.pop();
        }

        System.out.println(stack.size());

        // 4. peek()
        stack.push(100);
        stack.push(200);
        System.out.println(stack.peek());
        System.out.println(stack.size());
    }
}
</code></pre>
<pre><code class="language-java">//스택의 기본 구조
class Stack {
    // 스택 배열
    private int[] stack;
    // top위치
    private int top;
    // 스택의 최대 크기
    private int size;

    // 생성자
    public Stack(int size) {
        this.stack = new int[size];
        this.size = size;
        this.top = -1;
    }
}

public class StackTest {
    public static void main(String[] args) {
        Stack stack = new Stack(10);
    }
}</code></pre>
<h3 id="보조연산-구현-방법-3개">보조연산 구현 방법 (3개)</h3>
<pre><code class="language-java">    // isEmpty : 스택에 요소가 하나도 없으면 true 반환 (아니라면 false 반환)
    public boolean isEmpty() {
        return this.top == -1;
    }

    // isFull : 스택에 요소가 꽉 차있다면 true 반환 (아니라면 false 반환)
    public boolean isFull() {
        return this.top == this.size -1;
    }

    // peek : 스택 최상단에 있는 원소를 반환 (삭제 절대 아님 !!)
    public int peek() {
        return stack[top];
    }</code></pre>
<h3 id="메인연산-구현-방법">메인연산 구현 방법</h3>
<pre><code class="language-java">    // push : 스택에 원소를 삽입
    public boolean push(int item) {
        // 스택에 요소가 이미 꽉 차 있는 상황이라면 삽입 중단 !
        if(isFull()) {
            // 꽉 차있는 상황이므로 ..
            return false; // 삽입 중단
        }
        // top의 위치를 한칸 올리고 (증가)
        top++;
        //그 위치(top)에 item을 저장 (할당)
        stack[top] = item;

        return true; //정상 삽입 !
    }

    // pop : 스택에 원소를 제거하고 반환
    public int pop() {
        // 스택이 비어있는 경우, pop 종료 !
        if(isEmpty()) {
            System.out.println(&quot;스택이 비어있어요 ㅠㅠ&quot;);
//            throw new RuntimeException(&quot;스택 언더플로우&quot;); 가 정석임
            return -1; //에러 값..
        }

        int temp = stack[top];
        top--;
        return stack[top]; 
    }</code></pre>
<pre><code class="language-java">//스택의 기본 구조
class Stack {
    // 스택 배열
    private int[] stack;
    // top위치
    private int top;
    // 스택의 최대 크기
    private int size;

    // 생성자
    public Stack(int size) {
        this.stack = new int[size];
        this.size = size;
        this.top = -1;
    }

    // isEmpty : 스택에 요소가 하나도 없으면 true 반환 (아니라면 false 반환)
    public boolean isEmpty() {
        return this.top == -1;
    }

    // isFull : 스택에 요소가 꽉 차있다면 true 반환 (아니라면 false 반환)
    public boolean isFull() {
        return this.top == this.size - 1;
    }

    // peek : 스택 최상단에 있는 원소를 반환 (삭제 절대 아님 !!)
    public int peek() {
        return stack[top];
    }

    // push : 스택에 원소를 삽입
    public boolean push(int item) {
        // 스택에 요소가 이미 꽉 차 있는 상황이라면 삽입 중단 !
        if (isFull()) {
            // 꽉 차있는 상황이므로 ..
            return false; // 삽입 중단
        }
        // top의 위치를 한칸 올리고 (증가)
        top++;
        // 그 위치(top)에 item을 저장 (할당)
        stack[top] = item;

        return true; // 정상 삽입 !
    }

    // pop : 스택에 원소를 제거하고 반환
    public int pop() {
        // 스택이 비어있는 경우, pop 종료 !
        if (isEmpty()) {
            System.out.println(&quot;스택이 비어있어요 ㅠㅠ&quot;);
//            throw new RuntimeException(&quot;스택 언더플로우&quot;); 가 정석임
            return -1; // 에러 값..
        }

        int temp = stack[top];
        top--;
        return stack[temp];
    }

}

public class StackTest {
    public static void main(String[] args) {
        Stack stack = new Stack(5);

        // 스택에 1,2,3,4,5,6 까지 삽입
        for (int i = 0; i &lt;= 6; i++) {
            stack.push(i);
            System.out.print(i + &quot;-&gt;&quot;);
        }
        System.out.println();
        System.out.println(&quot;=====================================&quot;);
        // 스택에서 값을 6번 삭제해보기
        for (int i = 0; i &lt;= 6; i++) {
            int result = stack.pop();
            System.out.print(result + &quot;-&gt;&quot;);
        }

    }
}
</code></pre>
<h2 id="function-call시스템-스택">Function call(시스템 스택)</h2>
<ul>
<li>프로그램에서 함수 호출과 복귀에 따른 순서를 관리</li>
<li>가장 마지막에 호출 된 함수가 가장 먼저 실행을 완료하고 복귀하는 후입선출 구조</li>
<li>함수 호출 시 함수 수행에 필요한 지역변수, 매개변수, 복귀 주소 등의 정보를 스택 프레임에 저장하여 시스템 스택에 삽입</li>
<li>함수의 실행이 끝나면 시스템 스택의 top원소를 pop하여 복귀 주소로 복귀</li>
<li>프로그램 종료 시 시스템 스택은 공백이 됨</li>
</ul>
<p><img alt="" src="https://velog.velcdn.com/images/danhye821/post/1cca1c9b-7052-4024-b3d9-8631ff23abae/image.png" /></p>
<p>*참조자료형 공부 해보자</p>
<pre><code class="language-java">//Ctrl + z (실행 취소)        
//Ctrl + y (실행 취소의 취소)

import java.util.Scanner;
import java.util.Stack;

public class Stack05_뒤로앞으로 {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        String page = &quot;Google&quot;; // 시작페이지

        Stack&lt;String&gt; 뒤로 = new Stack&lt;&gt;();
        Stack&lt;String&gt; 앞으로 = new Stack&lt;&gt;();

        // 일단 페이지를 입력받아서 거기부터 시작이야!
//        do {
//            
//        }while();

        while (true) {
            System.out.println(&quot;1. 새로운 페이지 방문&quot;);
            System.out.println(&quot;2. 뒤로가기&quot;);
            System.out.println(&quot;3. 앞으로가기&quot;);
            System.out.println(&quot;0. 종료버튼(그 외 다른거 눌러도 종료됨)&quot;);

            int cmd = sc.nextInt(); // 선택메뉴
            switch (cmd) {
            case 1:
                System.out.println(&quot;새로운 페이지 입력&quot;);
                // 1.현재 페이지를 뒤로 스택에 push
                뒤로.push(page);
                // 2.새로운 페이지를 입력
                page = sc.next(); // 공백은 없이 입력이 된다 가정
                // 3. 앞으로 스택을 비워야한다.
                // 3-1. 반복문을 이용해서 죄다 꺼내기
                // 3-2. 새로운 스택 생성하기
                // 3-3. clear() 활용하기
                앞으로.clear();
                // 4.현재 페이지 출력
                System.out.println(&quot;브라우저 : &quot; + page);

                break;
            case 2:
                // 뒤로가기 없다면 비활성화된 상태
                if (뒤로.isEmpty()) {
                    System.out.println(&quot;비활성화 된 버튼을 누르려고 하다니.&quot;);
                } else {
                    System.out.println(&quot;뒤로 갑니다.&quot;);
                    // 1. 현재 페이지를 앞으로 스택에 넣는다.
                    앞으로.push(page);
                    // 2. 현재 페이지는 뒤로 스택에서 꺼내온다.
                    page = 뒤로.pop();
                    // 3. 현재 페이지 출력
                    System.out.println(&quot;브라우저 : &quot; + page);
                }

                break;
            case 3:
                System.out.println(&quot;앞으로 갑니다.&quot;);
                if (앞으로.isEmpty()) {
                    System.out.println(&quot;앞으로 갈게 없어서.. 갈 수 없겠는걸?&quot;);
                } else {
                    // 1.현재 페이지를 뒤로 스택에 넣는다.
                    뒤로.push(page);
                    // 2.현재 페이지는 앞으로 스택에서 꺼내온다.
                    page = 앞으로.pop();
                    // 3.현재 페이지 출력
                    System.out.println(&quot;브라우저 : &quot; + page);
                }
                break;
            default:
                System.out.println(&quot;종료합니다.&quot;);
                return;
            }
        }

    }
}
</code></pre>