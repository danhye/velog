<p><img alt="" src="https://velog.velcdn.com/images/danhye821/post/4b84b5de-82cf-4e6c-828e-2508029954a5/image.png" />
<img alt="" src="https://velog.velcdn.com/images/danhye821/post/18424f5f-a1a3-4727-9e86-27df57d32f1e/image.png" /></p>
<p>여러가지 방법으로 풀어보기 !</p>
<h3 id="방법1-반복문으로-풀기">방법1. 반복문으로 풀기</h3>
<pre><code class="language-java">package Baekjoon;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

public class 나머지_3052 {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

        // 42로 나눈 나머지 배열에 담기
        int[] arr = new int[10];
        for (int i = 0; i &lt; 10; i++) {
            StringTokenizer st = new StringTokenizer(br.readLine());
            arr[i] = (Integer.parseInt(st.nextToken())) % 42;
        }

        int count = 0;
        for (int i = 0; i &lt; arr.length; i++) {
            boolean equal = false;
            for (int j = 0; j &lt; i; j++) {
                if(arr[i] == arr[j]) {
                    // 값이 같으면 true로 변경
                    equal = true;
                    // 반복문 나가기
                    break;
                }
            }
            // 서로 다른 값 출력
            if(equal == false) count++;
        }

        System.out.println(count);
    }
}
</code></pre>
<br />
<br />

<h3 id="방법2-배열로-풀기">방법2. 배열로 풀기</h3>
<pre><code class="language-java">package Baekjoon;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class 나머지_3052 {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

        // 42로 나눈 후 발생할 수 있는 나머지 값으로 boolean 배열 생성
        boolean[] mod = new boolean[42];

        for (int i = 0; i &lt; 10; i++) {
            int num = Integer.parseInt(br.readLine()) % 42;
            // 나머지 값의 index에 true
            mod[num] = true;
        }

        int count = 0;
        for (int i = 0; i &lt; mod.length; i++) {
            if(mod[i]) count++;
        }

        System.out.println(count);
    }
}</code></pre>
<p><br /><br /></p>
<h3 id="방법3-hashset으로-풀기">방법3. HashSet으로 풀기</h3>
<pre><code class="language-java">package Baekjoon;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.HashSet;
import java.util.Set;

public class 나머지_3052 {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

        Set&lt;Integer&gt; rest = new HashSet&lt;&gt;();
        for (int i = 0; i &lt; 10; i++) {
            int num = Integer.parseInt(br.readLine()) % 42;
            rest.add(num);
        }
        System.out.println(rest.size());
    }
}</code></pre>
<h2 id="hashset-">HashSet ?</h2>
<h3 id="set-">Set ?</h3>
<ul>
<li>비선형 구조</li>
<li>순서, 인덱스 없음 </li>
<li>검색 후 값을 추가 / 삭제 가능하기에 -&gt; 처리 속도가 List 에 비해 느리다</li>
<li>객체를 중복해서 저장 X</li>
<li>하나의 null 값만 저장</li>
<li>저장 순서가 보장되지 않는다.</li>
</ul>
<h3 id="hashset--1">HashSet ?</h3>
<ul>
<li>중복 된 값은 자동 제거 된다.</li>
<li>저장한 순서가 보장되지 않는다.</li>
<li>null 값을 허용한다.</li>
<li>정렬 X</li>
</ul>
<blockquote>
<p>저장 순서를 유지해야 할 경우 -&gt; <strong>LinkedHashSet</strong></p>
</blockquote>
<blockquote>
<p>자동 정렬이 필요 할 경우 -&gt; <strong>TreeSet</strong> </p>
</blockquote>