<h1 id="상속">상속</h1>
<ul>
<li><p>상위 클래스의 속성과 메서드를 물려받아 확장하여 새로운 자식 클래스를 정의하는 것</p>
</li>
<li><p>extends 키워드 사용</p>
<ul>
<li><p>상속 받지 않은 예시</p>
<pre><code class="language-java">package inheritance01_no;

public class Student {
  String name;
  int age;
  String major;

  public void eat() {
      System.out.println(&quot;음식을 먹는다.&quot;);
  }

  public void study() {
      System.out.println(&quot;공부를 한다.&quot;);
  }
}
</code></pre>
</li>
<li><p>상속 받은 예시</p>
<pre><code class="language-java">package inheritance02_ok;
//Person 상속 받기 위해서 extends 키워드를 사용하겠다.
public class Student extends Person{
  String major;

  public void study() {
      System.out.println(&quot;공부를 한다.&quot;);
  }
}</code></pre>
</li>
<li><p>오프라인 예시</p>
<pre><code class="language-java">// 부모 클래스 (Parent Class, Super Class)
class Animal {
  protected String name;

  void eat() {
      System.out.println(&quot;동물이 먹이를 먹습니다.&quot;);
  }
}

// 자식 클래스 (Child Class, Sub Class)
class Dog extends Animal {
  void bark() {
      System.out.println(&quot;멍멍!&quot;);
  }
}

// main 메서드에다가...
Dog d = new Dog();
d.eat(); // 사용 O
System.out.println(d.name); // 사용 O

d.name(); // 이건 안됨, 사용 용도가 없기 때문에</code></pre>
</li>
</ul>
</li>
</ul>
<h3 id="object">object</h3>
<ul>
<li>최상위 부모 클래스</li>
<li>기본적으로 상속 받는 클래스 ( 상속 명시하지 않을 경우 ! )</li>
</ul>
<p>object 클래스 생성 가능</p>
<p>왜? 패키지 구조가 다르기 때문에 가능하다 ~~</p>
<h2 id="상속의-특징">상속의 특징</h2>
<ul>
<li><p>코드 <strong>재사용성</strong> : 상위 클래스에 정의된 필드, 메서드 사용 가능, 공통된 기능을 상위 클래스에 정의</p>
<ul>
<li>공통된 기능을 상위 클래스에 정의 → 상위 클래스 변경 시 모든 하위 클래스 적용</li>
<li>유지보수가 용의하다</li>
</ul>
</li>
<li><p><code>extends</code>  키워드를 통해 구현</p>
</li>
<li><p>다중 상속 불가능 (오직 하나만 가능 !) ← 다이아몬드 문제 방지하기 위해서</p>
<ul>
<li><p>다이아몬드 문제란 ?</p>
<ul>
<li>두 부모의 클래스가 같은 메서드를 가질 때 어떤 메서드를 상속 받아야하나?</li>
<li>모호해지는 문제</li>
<li>강제 문법적으로 X</li>
</ul>
</li>
<li><p>인터페이스를 사용하여 다중 상속과 비슷한 효과를 구현할 수 있음</p>
<pre><code class="language-java">  // 인터페이스(interface) 란? 클래스에게 반드시 구현해야하는 메서드를 정의
  // 일종의 &quot;설계요구서&quot;
  // &quot; ~~~~ 것들을 할 수 있어요!!&quot; 라는 행위들을 정의하는 곳

  interface Flyable {
      void fly(); // &quot;날기&quot; 기능을 구현해주세요
  }

  interface Swimmable {
      void swim(); // &quot;수영하기&quot; 기능을 만들어주세요
  }

  // 인터페이스를 통해서 다중 구현(imple) 가능
  class Duck extends Animal implements Flyable, Swimmable {
      @Override
      void fly(){
          System.out.println(&quot;오리가 날아갑니다 ~&quot;);
      }

      @Override
      void swim(){
          System.out.println(&quot;오리가 수영을 즐깁니다~&quot;);
      }
  }</code></pre>
</li>
</ul>
</li>
<li><p>상위 클래스의 생성자와 초기화 블록은 상속하지 않음</p>
</li>
<li><p>접근제한자에 따라 상위 클래스의 멤버에 대한 접근 범위가 결정됨</p>
</li>
<li><p>공통된 기능이 정의되어 있는 상위 클래스만 수정하면 하위 클래스는 모두 적용</p>
</li>
</ul>
<h3 id="is-a-관계-상속-관계">is-a 관계 (상속 관계)</h3>
<ul>
<li>“A는 B이다.” 라는 <strong>상속</strong>을 통한 관계</li>
<li>상위 클래스는 하위 클래스의 공통된 특성과 행동을 정의하며, 하위 클래스는 이를 확장하거나 구체화</li>
<li>일반화와 전문화가 필요한 경우 사용</li>
</ul>
<h3 id="has-a-관계-포함-관계">has-a 관계 (포함 관계)</h3>
<ul>
<li>“A는 B를 가지고 있다. “ 라는 포함을 통한 관계</li>
<li>한 클래스가 다른 클래스의 객체를 <strong>속성, 멤버 변수</strong>으로 포함하여 구현</li>
<li>구성요소를 나타낼  때 사용</li>
<li>두 클래스는 독립적</li>
</ul>
<p>참고) </p>
<pre><code class="language-java">class Car{
    private Car car; //가능
}</code></pre>
<p><img alt="image.png" src="attachment:90e8cb81-d4d6-4845-b46b-79a4ced02ca3:image.png" /></p>
<h2 id="this-키워드">this 키워드</h2>
<ul>
<li>현재 객체 자신을 참조</li>
<li>인스턴스 변수와 매개변수 이름이 같을 때 구분하고자 (지역변수가 같을 때에도)</li>
<li>같은 클래스의 다른 생성자 호출</li>
</ul>
<pre><code class="language-java">class Person {
    String name;
    int age;
    static int pCount // 총 인구수

    // 생성자
    Person (String name, int age){
        this.name = name; //this.name은 인스턴스 변수
        this.age = age;
    }

    // 다른 생성자도 호출 가능 !
    Person (String name) {
        this(name,0); // 다른 생성자를 this() 호출
    }
}</code></pre>
<h2 id="super-키워드">super 키워드</h2>
<ul>
<li>상위(=부모) 클래스의 멤버(필드, 메서드, 생성자)를 참조하는데 사용</li>
<li>상위 클래스와 관련된 작업을 수행할 때 사용</li>
<li>하위 클래스에서 상위 클래스와 동일한 이름의 필드가 있을 경우, super을 사용하여 필드를 참조</li>
<li>하위 클래스에서 상위 클래스의 메서드를 호출하여 기능을 유지하거나 확장할 수 있음</li>
<li>하위 클래스의 생성자에서 super()을 사용하여 상위 클래스의 생성자를 명시적으로 호출할 수 있음</li>
<li>super()는 반드시 생성자의 첫 번째 줄에 위치</li>
<li>명시적으로 작성하지 않으면 컴파일러는 기본 생성자를 호출</li>
<li>this()와 같이 사용할 수 없음</li>
<li>부모클래스의 멤버 변수나 메서드에 접근 (컴파일 시점에 결정 = 정적 바인딩)</li>
</ul>
<pre><code class="language-java">class Animal {
    String name;

    Animal(String name) {
        this.name = name;
    }

    void makeSound() {
        System.out.println(&quot;동물 소리&quot;);
    }
}

class Dog extends Animal {
    String breed;

    Dog(String name, String breed) {
        super(name);  // 부모 클래스의 생성자 호출 (컴파일 시점에 결정 = 정적 바인딩)
        this.breed = breed;
    }

    @Override
    void makeSound() {
        super.makeSound();  // 부모 클래스의 메서드 호출 (정적 바인딩)
        System.out.println(&quot;멍멍!&quot;);
    }
}</code></pre>
<h1 id="메서드-재정의-overriding">메서드 재정의 Overriding</h1>
<p>: 부모 클래스의 메서드를 자식 클래스에서 재정의</p>
<ul>
<li>메서드 이름, 매개 변수, 반환 타입이 상위 클래스와 동일 해야 함</li>
<li>접근 제한자는 상위 클래스의 메서드보다 더  넓은 범위로만 변경 가능</li>
<li>조상보다 더 큰 예외를 던질 수 없음</li>
<li><code>@Override</code> 어노테이션 사용 권장<ul>
<li>어노테이션? 주석 / 컴파일러, JVM, 프레임워크 등이 보는 주석 / 소스코드에 메타 데이터를 삽입하는 형태</li>
</ul>
</li>
<li>런타임 시 실제 객체 타입에 따라 호출되는 메서드가 결정 ! (=동적 바인딩)</li>
<li>메서드 오버로딩(Overloading)과 다른 개념</li>
</ul>
<pre><code class="language-java">class Animal {
    String name;

    Animal(String name) {
        this.name = name;
    }

    void makeSound() {
        System.out.println(name + &quot;이(가) 소리를 냅니다.&quot;);
    }
}

class Cat extends Animal {
    Cat(String name) {
        super(name);
    }

    @Override
    void makeSound() {
        System.out.println(name + &quot;이(가) 야옹~ 하고 웁니다.&quot;);
    }
}

class Dog extends Animal {
    Dog(String name) {
        super(name);
    }

    @Override
    void makeSound() {
        System.out.println(name + &quot;이(가) 멍멍! 하고 짖습니다.&quot;);
    }
}

// 퀴즈1.
Dog d1 = new Dog(&quot;퍼피&quot;);
d1.makeSound() // 출력: 퍼피이(가) 멍멍! 하고 짖습니다.

Cat c1 = new Cat(&quot;캣츠&quot;);
c1.makeSound() // 출력: 캣츠이(가) 야옹~ 하고 웁니다.

// 퀴즈2.
Animal a1 = new Dog(&quot;초코&quot;);
a1.makeSound(); // 출력: 초코이(가) 멍멍! 하고 짖습니다.</code></pre>
<p>문제1)</p>
<pre><code class="language-java">class A {
    protected int x = 10;  // A의 x
}

class B extends A {
    protected int x = 20;  // B의 x
    // 필드는 상속되지 않고 숨겨진다(hiding) 
    // 오버라이딩x hiding 현상o
}

class C extends B {
    protected int x = 30;  // C의 x

    public void accessFields() {
        // 함정 : &quot;필드&quot;들은 동적 바인딩 대상이 아니다...!
        //       정적 바인딩 -&gt; 컴파일 시점에 결정되는 것
        System.out.println(&quot;C의 x: &quot; + this.x);     // 30
        System.out.println(&quot;B의 x: &quot; + ((B)this).x);     // 20
        System.out.println(&quot;A의 x: &quot; + ((A)this).x);     // 10
    }
}

public class Main {
    public static void main(String[] args) {
        C c = new C();
        c.accessFields();
    }
}</code></pre>
<p>정답1)</p>
<pre><code class="language-java">package inheritance;

class A {
    protected int x = 10;  // A의 x
}

class B extends A {
    protected int x = 20;  // B의 x
    // 필드는 상속되지 않고 숨겨진다(hiding) 
    // 오버라이딩x hiding 현상o

    public int getX() {
        return super.x;
    }
}

class C extends B {
    protected int x = 30;  // C의 x

    public void accessFields() {
        // 함정 : &quot;필드&quot;들은 동적 바인딩 대상이 아니다
        //                  정적 바인딩 -&gt; 컴파일 시점에 결정 되는 것
        System.out.println(&quot;C의 x: &quot; + this.x );     // 30

        System.out.println(&quot;B의 x: &quot; + super.x);     // 20
        System.out.println(&quot;B의 x: &quot; + ((B)this).x);     // 20

        System.out.println(&quot;A의 x: &quot; + super.getX());     // 10
        System.out.println(&quot;A의 x: &quot; + ((A)this).x);     // 10
    }
}

public class Main {
    public static void main(String[] args) {
        C c = new C();
        c.accessFields();
    }
}
</code></pre>
<hr />
<p>문제2)</p>
<pre><code class="language-java">class A {
    protected int x = 10;
    public void method() { 
        System.out.println(&quot;A의 method&quot;); 
    }
}

class B extends A {
    protected int x = 20;
    @Override
    public void method() { 
        System.out.println(&quot;B의 method&quot;);
        super.method();
    }
}

class C extends B {
    protected int x = 30;
    @Override
    public void method() { 
        System.out.println(&quot;C의 method&quot;);
        // super 키워드는 우회적으로 &quot;정적바인딩&quot;으로 
        //                  부모 클래스를 호출하는 키워드!
        super.method();
    }

    public void accessMethod() {
        // 메서드는 동적바인딩 대상이다...!
        // 동적바인딩 -&gt; 런타임(runtime) 시점에 객체에 따라 결정!
        this.method();
    }
}

public class Main {
    public static void main(String[] args) {
             C c1 = new C();
             c1.accessMethod();   
    }
}</code></pre>
<p>정답2)</p>
<pre><code class="language-java">package inheritance.copy;

class A {
    protected int x = 10;
    public void method() { System.out.println(&quot;A의 method&quot;); }
}

class B extends A {
    protected int x = 20;
    @Override
    public void method() { 
        System.out.println(&quot;B의 method&quot;); 
        super.method();
    }

    public void getMethod() {
        super.method();
    }
}

class C extends B {
    protected int x = 30;
    @Override
    public void method() { 
        System.out.println(&quot;C의 method&quot;); 
        super.method();
    }

    public void accessMethod() {
        this.method();
        super.method(); // super 키워드는 우회적으로 정적 바인딩으로 부모 클래스를 호출하는 키워드
        super.getMethod();

        //메서드는 동적바인딩 대상이다
        //동적 바인딩 -&gt; 런타임(runtime) 시점에 객체에 따라 정답
//        System.out.println(&quot;동적, 정적 바인딩 테스트&quot;);
//        this.method();        // C의 method
//        ((B)this).method(); // C의 method
//        ((A)this).method(); // C의 method

        System.out.println(&quot;=====두번째 정답(super.method() 추가)=====&quot;);
        this.method();
    }
}

public class Main {
    public static void main(String[] args) {
        C c1 = new C();  
        c1.accessMethod();
    }
}
</code></pre>
<h1 id="object-클래스">Object 클래스</h1>
<ul>
<li>자바의 가장 최상위 클래스로 모든 클래스의 조상</li>
<li>모든 클래스는 직접적으로나 간접적으로 Object를 상속 받음</li>
<li><code>java.lang.Object</code> 에 선언되어 있음</li>
<li>Object의 멤버는 모든 클래스의 멤버</li>
</ul>
<p><img alt="image.png" src="attachment:bb83f76c-bd0d-4896-a71e-c81b064e66b8:image.png" /></p>
<h2 id="tostring-메서드">toString() 메서드</h2>
<ul>
<li>객체를 문자열로 변경하는 메서드</li>
<li>기본 구현 : 클래스명@해시코드</li>
<li>보통 의미있는 정보를 출력하기 위해 오버라이드 대상</li>
</ul>
<pre><code class="language-java">class Person {
    String name;
    int age;

    Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    @Override
    public String toString() {
        return &quot;Person[name='&quot; + name + &quot;', age=&quot; + age + &quot;]&quot;;
    }
}

// 사용 예
Person p = new Person(&quot;홍길동&quot;, 25);
System.out.println(p.toString()); // Person{name='홍길동', age=25}
System.out.println(p);            // toString() 자동 호출</code></pre>
<h1 id="객체-동등성-비교">객체 동등성 비교</h1>
<p>자바에서는 객체(Object)의 비교에 대해서 동등성(서로 같다)을 판단할 때에 아래의 과정을 거쳐서 판단을 진행 <code>hashCode() -&gt; equals()</code></p>
<p><img alt="image.png" src="attachment:a07cd6e2-eca3-48b9-a85f-509bca39af12:image.png" /></p>
<p>Why ? 왜 이렇게 하나요 ? </p>
<p><strong>성능 최적화</strong> 때문에</p>
<p>hashCode()는 정수 비교만 수행하면 되기 때문에 매우 빠르다!</p>
<p>but, 가끔 이러한 해쉬코드 비교가 서로 충돌(같은 값)이 발생하는 경우가 있기에</p>
<p>그 후에 안정적을 위해서 필드값을 직접 비교하는 equals() 연산을 그 후에 사용하도록 보완</p>
<ul>
<li><p>충돌 케이스</p>
<pre><code class="language-java">  public class Main {
      public static void main(String[] args) {
          String str1 = &quot;BB&quot;;
          String str2 = &quot;Aa&quot;;

          System.out.println(str1.hashCode());
          System.out.println(str2.hashCode());
      }
  }</code></pre>
</li>
</ul>
<p>차후에 JCf (Java Collection Framework) 자료구조 시간에 해쉬(hash)를 사용하는 자료구조 (HashMap, HashSet)에서 한번 더 언급 될 예정 ㅎ</p>
<h2 id="equals-메서드">equals() 메서드</h2>
<ul>
<li>두 객체가 논리적으로 같은 지 비교하는 메서드</li>
<li>기본 구현 : 참조값(주소) 비교 (==연산자와 동일)</li>
<li>논리적인 동등성을 위해서 우리가 오버라이드 하는 메서드</li>
</ul>
<pre><code class="language-java">class Person {
    String name;
    int age;

    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null || getClass() != obj.getClass()) return false;

        Person person = (Person) obj;
        return age == person.age &amp;&amp;
               Objects.equals(name, person.name);
    }
}</code></pre>
<h2 id="hashcode-메서드">hashCode() 메서드</h2>
<ul>
<li>객체의 해쉬코드 값을 반환</li>
<li>equals()를 오버라이드 하면 hashCode() 도 함께 오버라이드 해야 함</li>
<li>같은 객체는 항상 같은 해쉬코드를 가져간다.</li>
</ul>
<pre><code class="language-java">class Person {
    String name;
    int age;
    int height;

    @Override
    public int hashCode() {
        return age * 10000 + height;
    }
}</code></pre>
<ol>
<li>객체를 빠르게 검색하거나 비교할 때 사용</li>
<li>기본적으로 메모리 주소 기반으로 생성하지만 재정의 가능</li>
</ol>
<ul>
<li>HashSet. HashMap 등 에서 객체의 동일성을 확인하기 위해 사용</li>
<li>equals 메서드를 재정의 할 대는 반드시 hashCode() 도 재정의 할 것</li>
<li>미리 작성된 String이나 Number등에서 재정의 된 hashCode() 활용 권장</li>
<li>해쉬값이 다르면 두 값은 무조건 다름</li>
</ul>
<h2 id="getclass-메서드">getClass() 메서드</h2>
<p>객체의 런타임 클래스 정보를 반환</p>
<h3 id="기타-주요-메서드">기타 주요 메서드</h3>
<p>getClass() : 객체의 클래스 정보 반환</p>
<p>clone() : 객체를 복원하여 반환 (Cloneable 인터페이스를 구현할 필요)</p>
<p>wait(), notify(), notifyAll() : 스레드 동기화</p>
<h1 id="final">final</h1>
<ul>
<li>변경 불가능성을 나타내는 키워드</li>
<li>컴파일 타임 안정성을 높이는데 사용</li>
<li>변수 : 값의 고정성</li>
<li>메서드 : 재정의 방지</li>
<li>클래스 : 상속 불가능</li>
<li>과도한 사용은 코드의 유연성을 감소 시킴</li>
</ul>
<table>
<thead>
<tr>
<th>적용 대상</th>
<th>효과</th>
</tr>
</thead>
<tbody><tr>
<td>변수</td>
<td>값 변경 불가 (상수)</td>
</tr>
<tr>
<td>메서드</td>
<td>오버라이드 불가</td>
</tr>
<tr>
<td>클래스</td>
<td>상속 불가</td>
</tr>
</tbody></table>
<h2 id="final-변수">final 변수</h2>
<ul>
<li>값이 변경되지 않는 상수를 선언할 때 사용</li>
<li>선언과 동시에 초기화 혹은 생성자를 통한 초기화를 해야함</li>
<li>참조 변수에 final을 사용하면 참조를 바꿀 수는 없지만 객체의 내부 상태는 변경 가능</li>
</ul>
<pre><code class="language-java">class Example {
    final int CONSTANT = 100;           // 상수
    final int value;                    // 생성자에서 초기화 필요

    Example(int value) {
        this.value = value;             // 생성자에서 한 번만 초기화 가능
    }

    void method() {
        final int localVar = 50;        // 지역 상수
        // localVar = 60;               // 컴파일 오류!

        final Object obj = new Object();// 다른 객체로 교환 불가
    }
}</code></pre>
<p>사용 시 변수명 대문자</p>
<h2 id="final-메서드">final 메서드</h2>
<ul>
<li>재정의(Overriding) 금지 → 하위 클래스에서 재정의 할 수 없음</li>
<li>상위 클래스에서 중요한 동작을 변경되지 않도록 보호할 때 사용</li>
</ul>
<h2 id="final-클래스">final 클래스</h2>
<ul>
<li>상속할 수 없는 클래스 정의</li>
<li>클래스 자체를 확장할 필요가 없거나, 보안을 강화해야 하는 경우 사용</li>
<li>String 클래스는 final로 사용되어 있음</li>
</ul>
<hr />
<h1 id="다형성">다형성</h1>
<p>여러가지 형태를 받아들일 수 있는 특징</p>
<ul>
<li><p>동일한 이름의 메서드를 다른 객체 또는 서브클래스에서 호출할 수 있는 능력</p>
</li>
<li><p>하나의 인터페이스를 통해서 여러 형태의 구현(Implements)을 다룰 수 있는 OOP 개념</p>
</li>
<li><p>실제 하나의 객체를 다양한 타입의 참조로 사용할 수 있음</p>
</li>
<li><p>다양한 유형의 여러 객체를 하나의 공통된 타입으로 참조할 수 있음</p>
</li>
<li><p>상속 관계에 있을 때 조상 클래스 타입으로 자손 클래스의 객체를 참조할 수 있음</p>
</li>
<li><p>다양한 타입으로 참조하더라도 참조만 바뀔 뿐 실제 객체 자체(객체의 행위)는 변함 없음</p>
</li>
</ul>
<h2 id="다형성의-특징">다형성의 특징</h2>
<ul>
<li><p><strong>동적 바인딩</strong> : 런타임 시에 실제 객체의 타입에 따라 메서드 결정</p>
<ul>
<li><p>동적 바인딩을 어떻게 구현했는지</p>
<pre><code>  https://hyunsb.tistory.com/58</code></pre></li>
<li><p>주의 !  <strong>메서드</strong> 호출은 런타임 시에 결졍 = <strong>동적 바인딩</strong></p>
</li>
<li><p><strong>필드</strong> 호출은 컴파일 시에 결정 = <strong>정적 바인딩</strong></p>
</li>
</ul>
</li>
<li><p>확장성, 재사용성</p>
</li>
</ul>
<h2 id="다형성의-장점">다형성의 장점</h2>
<ul>
<li>코드의 유연성 → 상위 클래스 또는 인터페이스 타입으로 다룰 수 있음</li>
<li>코드의 재사용성 → 공통 동작을 상위 클래스 또는 인터페이스에 정의하여 중복 코드를 제거</li>
<li>확장성 → 새로운 클래스 추가 시 기존 코드 없이도 쉽게 확장 가능</li>
<li>유지보수성 → 변경 사항이 상위 클래스나 인터페이스를 수정하면 되므로 용이</li>
</ul>
<h2 id="오버로딩과-오버라이딩">오버로딩과 오버라이딩</h2>
<ul>
<li><strong>오버로딩</strong>(Overloading) : 같은 클래스 내에서 매개변수가 서로 다른 동일한 이름의 메서드를 정의</li>
</ul>
<pre><code class="language-java">class Calculator {
    // 기본 덧셈 메서드 add 정의
    public static int add(int a, int b){
        return a + b;
    }

    public static int add(int a, int b, int c){
        return a + b + c;
    }
}</code></pre>
<ul>
<li><strong>오버라이딩</strong>(Overriding) : 상속 받은 메서드를 자식 클래스에서 재정의</li>
</ul>
<pre><code class="language-java">// 도형 (모양)
class Shape {
    protected String color; //색상

    //생성자
    public Shape(String color){
        this.color = color;
    }

    //도형의 면적
    public double getArea(){
        return 0.0;
    }
}

// 원
class Circle extends Shape {
    protected double radius; //반지름

    //생성자
    public Circle (double radius, String color){
        super(color);
        this.radius = radius;
    }

    @Override //어노테이션을 사용하는 것을 권장 ..! 근데 없어도 됨
    public double getArea(){
        return Math.PI * radius * radius;
    }
}</code></pre>
<h2 id="참조변수의-형-변환">참조변수의 형 변환</h2>
<ul>
<li>자손타입 → 조상타입 (묵시적 형 변환, 자동 형 변환, 작은 타입 → 큰 타입)</li>
<li>형 변환 생략 가능</li>
</ul>
<pre><code class="language-java">Student st = new Student();
Person p =st;</code></pre>
<ul>
<li>조상타입 → 자손타입 (명시적 형 변환, 큰 타입 → 작은 타입)</li>
<li>형 변환 생략 불가능</li>
</ul>
<pre><code class="language-java">person p = new Person();
// 형 변환 해줘야 함
Student st = (Student) p;

Person p = new Student();
Student st = (Student)p;</code></pre>
<h2 id="instanceof-연산자">instanceof 연산자</h2>
<ul>
<li>참조변수가 참조하고 있는 인스턴스의 타입을 확인하기 위해서 사용</li>
<li>결과를 boolean으로 반환</li>
<li>true가 반환이 되면 해당 타입으로 형 변환 가능</li>
</ul>
<pre><code class="language-java">package polymorphism01;

public class Test2 {
    public static void main(String[] args) {
//        Person p = new Person();
        Person p = new Student();

        //아래의 코드는 문법적으로 이슈 없지만 실행시키면 곤란한 코드 !
//        Student st = (Student) p;

        if(p instanceof Student) { //반환값이 true 라면
            Student st = (Student)p;
            st.study();
        }

        // java 16+ (패턴매칭 방법)
        if(p instanceof Student st) {
            st.study();
        }
    }
}
</code></pre>
<h2 id="참조변수와-인스턴스-멤버의-관계">참조변수와 인스턴스 멤버의 관계</h2>
<ul>
<li>상속 관계에서 멤버변수가 중복이 되면 참조 변수 타입에 따라 연결이 달라짐</li>
<li>메서드가 중복될 때(오버라이딩), 참조 변수의 타입에 상관 없이 항상 실제 인스턴스의 자식 클래스 메서드가 호출 ⇒ 동적 바인딩</li>
<li>static 메서드는 참조변수 타입의 영향을 받기 때문에 이를 방지하고자 클래스 이름으로 메서드 호출(권장)</li>
</ul>
<h1 id="추상클래스">추상클래스</h1>
<h3 id="추상클래스-정의">추상클래스 정의</h3>
<ul>
<li>cook() 메서드는 자손 클래스에서 반드시 재정의해서 사용되기 때문에 조상의 구현이 무의미</li>
<li>메서드의 선언부만 남기고 구현부는 ;로 대체</li>
<li>구현부가 없으므로 <code>abstract</code> 키워드를 메서드 선언부에 추가</li>
<li>추상 메서드가 없어도 됨</li>
<li><code>abstract</code> 키워드를 통해서 클래스 선언</li>
<li>why? <strong>직접 인스턴스를 생성하는 것을 불가능</strong>하게 만들기 위해 ! (객체화  불가)</li>
<li><strong>상속</strong>을 통해서만 사용 가능하게 하도록 하기 위해 !</li>
<li>공통 기능은 구현하고, 세부 구현은 자식 클래스에게 위임</li>
</ul>
<pre><code class="language-java">// 추상 클래스
abstract class Vehicle {
    protected String brand;
    protected String model;
    protected int year;

    // 일반 생성자
    public Vehicle(String brand, String model, int year) {
        this.brand = brand;
        this.model = model;
        this.year = year;
    }

    // 일반 메서드 (구현됨)
    public void displayInfo() {
        System.out.println(&quot;브랜드: &quot; + brand + &quot;, 모델: &quot; + model + &quot;, 연도: &quot; + year);
    }

    public void startEngine() {
        System.out.println(&quot;엔진을 시동합니다.&quot;);
    }

    public void stopEngine() {
        System.out.println(&quot;엔진을 정지합니다.&quot;);
    }

    // 추상 메서드 (자식 클래스에서 반드시 구현)
    public abstract void accelerate();
    public abstract void brake();
    public abstract void getMaxSpeed();
    public abstract String getFuelType();
}

// 자동차 클래스
class Car extends Vehicle {
    private int doors;

    public Car(String brand, String model, int year, int doors) {
        super(brand, model, year);
        this.doors = doors;
    }

    @Override
    public void accelerate() {
        System.out.println(&quot;자동차가 가속페달을 밟아 속도를 높입니다.&quot;);
    }

    @Override
    public void brake() {
        System.out.println(&quot;자동차가 브레이크를 밟아 정지합니다.&quot;);
    }

    @Override
    public void getMaxSpeed() {
        System.out.println(&quot;최대 속도: 200km/h&quot;);
    }

    @Override
    public String getFuelType() {
        return &quot;휘발유&quot;;
    }

    public void openTrunk() {
        System.out.println(&quot;트렁크를 엽니다.&quot;);
    }
}

// 오토바이 클래스
class Motorcycle extends Vehicle {
    private boolean hasSidecar;

    public Motorcycle(String brand, String model, int year, boolean hasSidecar) {
        super(brand, model, year);
        this.hasSidecar = hasSidecar;
    }

    @Override
    public void accelerate() {
        System.out.println(&quot;오토바이가 스로틀을 돌려 가속합니다.&quot;);
    }

    @Override
    public void brake() {
        System.out.println(&quot;오토바이가 핸드브레이크와 풋브레이크를 사용합니다.&quot;);
    }

    @Override
    public void getMaxSpeed() {
        System.out.println(&quot;최대 속도: 300km/h&quot;);
    }

    @Override
    public String getFuelType() {
        return &quot;휘발유&quot;;
    }

    public void wheelie() {
        System.out.println(&quot;앞바퀴를 들고 달립니다!&quot;);
    }
}

// 전기차 클래스
class ElectricCar extends Vehicle {
    private int batteryCapacity;

    public ElectricCar(String brand, String model, int year, int batteryCapacity) {
        super(brand, model, year);
        this.batteryCapacity = batteryCapacity;
    }

    @Override
    public void accelerate() {
        System.out.println(&quot;전기차가 조용히 가속합니다.&quot;);
    }

    @Override
    public void brake() {
        System.out.println(&quot;전기차가 회생제동으로 에너지를 회수하며 정지합니다.&quot;);
    }

    @Override
    public void getMaxSpeed() {
        System.out.println(&quot;최대 속도: 250km/h&quot;);
    }

    @Override
    public String getFuelType() {
        return &quot;전기&quot;;
    }

    public void chargeBattery() {
        System.out.println(&quot;배터리를 충전합니다. 용량: &quot; + batteryCapacity + &quot;kWh&quot;);
    }
}
</code></pre>
<h3 id="추상클래스-특징">추상클래스 특징</h3>
<ul>
<li><p>추상 메서드와 일반 메서드 모두 가질 수 있음</p>
</li>
<li><p>생성자, 인스턴스 변수, 일반 메서드 포함 가능</p>
</li>
<li><p><strong>자식 클래스를 통해서 모든 추상 메서드를 구현해야 한다.</strong></p>
</li>
<li><p>abstract 클래스는 상속 전용의 클래스</p>
</li>
<li><p>클래스에 구현부가 없는 메서드가 있으므로 객체를 생성할 수 없음</p>
</li>
<li><p>상위 클래스 타입으로 자식을 참조할 수는 있음</p>
</li>
<li><p>조상 클래스에서 상속 받은 abstract 메서드를 재정의 하지 않은 경우 → 클래스 내부에 abstract 메서드가 있으므로 자식 클래스는 abstract 클래스 필수</p>
</li>
<li><p>다중 상속 불가</p>
</li>
</ul>
<h3 id="추상클래스-사용-목적">추상클래스 사용 목적</h3>
<ul>
<li>공통적인 설계 강제 → 미완성의 메서드를 제공함으로써 구현을 강제 시킴</li>
<li>코드 재사용성 향상</li>
<li>일관성 유지 → 추상 메서드를 통해 하위 클래스가 동일한 동작을 가지도록 보장</li>
<li>다형성 지원 → 유연한 설계 가능</li>
</ul>
<p><img alt="image.png" src="attachment:0002b618-4e73-4965-a42e-9f2254139e70:image.png" /></p>
<h2 id="추상-클래스-vs-인터페이스">추상 클래스 vs 인터페이스</h2>
<table>
<thead>
<tr>
<th>구분</th>
<th>추상클래스</th>
<th>인터페이스</th>
</tr>
</thead>
<tbody><tr>
<td><strong>키워드</strong></td>
<td>abstract class</td>
<td>interface</td>
</tr>
<tr>
<td><strong>상속</strong></td>
<td>단일 상속 (extends)</td>
<td>다중 구현 (implements)</td>
</tr>
<tr>
<td><strong>메서드</strong></td>
<td>추상/일반 메서드 모두 가능</td>
<td>추상 메서드 위주 (Java 8+에서 ***default 메서드 가능)</td>
</tr>
<tr>
<td><strong>변수</strong></td>
<td>인스턴스 변수 가능</td>
<td>public static final 상수만 가능</td>
</tr>
<tr>
<td><strong>생성자</strong></td>
<td>가능</td>
<td>불가능</td>
</tr>
<tr>
<td><strong>접근제어자</strong></td>
<td>모든 접근제어자 사용 가능</td>
<td>public만 가능 (생략 시 public)</td>
</tr>
<tr>
<td><strong>목적</strong></td>
<td>공통 기능 제공 + 일부 강제 구현</td>
<td>완전한 추상화, 다중 상속 효과</td>
</tr>
</tbody></table>